
@implements  IAsyncDisposable

<PageTitle>@(GetFileTitle())</PageTitle>

@if (_loading || _hubConnection is null || !_hasNeededRank || _model is null || !_rightsSetted)
{
    <PageLoading/>
}
else if (_model is not null)
{
    <h1>@(GetFileTitle())</h1>
    <MudTabs Elevation="2" Rounded="true" ApplyEffectsToContainer="true" PanelClass="pa-6">
        <MudTabPanel Text="Allgemein" Icon="@Icons.Material.Filled.Info" OnClick="() => UnlockCharTab()">
            <MudGrid Justify="Justify.FlexStart">
                <MudItem xs="8">
                    <MudPaper Class="pa-4" Style="height: 70vh; overflow-y: auto;">
                        <MudTextField Label="DisplayId" Variant="Variant.Outlined" ReadOnly Value="@_model.DisplayId"/>
                        
                        <MudDivider Style="@_dividerStyle"/>
                        <MudTextField Label="Ersteller" Variant="Variant.Outlined" ReadOnly Value="@_model.CreatorAccessModel.Name"/>
                        
                        <MudDivider Style="@_dividerStyle"/>
                        <MudTextField Label="Erstellt am" Variant="Variant.Outlined" ReadOnly Value="@_model.CreatedAtLocal()"/>

                        <MudDivider Style="@_dividerStyle"/>
                        <MudTextField Label="Titel" Variant="Variant.Outlined" ReadOnly="@(_model.Deleted || !UserAccessService.HasRight(_canEditTitle))" @bind-Value="_model.Title"/>

                        <MudDivider Style="@_dividerStyle"/>
                        <MudTextField Label="Beschreibung" Lines="3" Variant="Variant.Outlined" ReadOnly="@(_model.Deleted || !UserAccessService.HasRight(_canEditDescription))" @bind-Value="_model.Description"/>

                        @if (_model.Type == FileTypeEnum.Supportfile)
                        {
                            <MudDivider Style="@_dividerStyle"/>
                            <MudSelect T="FileStatusEnum" Label="Status" Variant="Variant.Outlined" ReadOnly="@(_model.Deleted || !UserAccessService.HasRight(_canEditStatus))" @bind-Value="_model.Status">
                                @foreach (FileStatusEnum status in Enum.GetValues(typeof(FileStatusEnum)))
                                {
                                    <MudSelectItem Value="@(status)">@status.GetDisplayText()</MudSelectItem>
                                }
                            </MudSelect>

                            <MudDivider Style="@_dividerStyle"/>
                            <MudSelect T="RankEnum" Label="MinRank" Variant="Variant.Outlined" ReadOnly="@(_model.Deleted || !UserAccessService.HasRight(_canEditMinRank))" @bind-Value="_model.MinRank">
                                @foreach (RankEnum minRank in Enum.GetValues(typeof(RankEnum)))
                                {
                                    <MudSelectItem Value="@(minRank)">@minRank.GetDisplayText()</MudSelectItem>
                                }
                            </MudSelect>

                            <MudDivider Style="@_dividerStyle"/>
                            <MudSelect T="Ulid?" Label="Kategorie" Variant="Variant.Outlined" ReadOnly="@(_model.Deleted || !UserAccessService.HasRight(_canEditCategory))" @bind-Value="_model.CategoryId">
                                <MudSelectItem T="Ulid?" Value="@null">Keine Kategorie</MudSelectItem>
                                @foreach (var category in _categoryDbModels)
                                {
                                    <MudSelectItem T="Ulid?" Value="@(category.Id)">[@category.Number] @category.Name</MudSelectItem>
                                }
                            </MudSelect>
                        }
                    </MudPaper>
                </MudItem>

                @if (UserAccessService.HasRight(_canViewFileActions))
                {
                    <MudItem xs="4">
                        <MudPaper Class="pa-4">
                            <MudToolBar>
                                @if (!_model.Deleted && UserAccessService.HasAnyRights([_canEditTitle, _canEditDescription, _canEditStatus, _canEditMinRank, _canEditCategory]))
                                {
                                    <MudTooltip Text="Änderungen speichern" Duration="@Constants.TOOLTIP_DURATION">
                                        <MudIconButton Variant="Variant.Text" Color="Color.Primary" Icon="@Icons.Material.Filled.Save" OnClick="() => SaveChanges()"/>
                                    </MudTooltip>
                                }
                            
                                <MudSpacer />

                                @if (_model.Deleted && UserAccessService.HasRight(_canRestoreFile))
                                {
                                    <MudTooltip Text="Akte wiederherstellen" Duration="@Constants.TOOLTIP_DURATION">
                                        <MudIconButton Variant="Variant.Text" Color="Color.Success" Icon="@Icons.Material.Filled.RestoreFromTrash" OnClick="() => ToggleFileDeleted()"/>
                                    </MudTooltip>
                                }
                                else if (!_model.Deleted && UserAccessService.HasRight(_canDeleteFile))
                                {
                                    <MudTooltip Text="Akte löschen" Duration="@Constants.TOOLTIP_DURATION">
                                        <MudIconButton Variant="Variant.Text" Color="Color.Error" Icon="@Icons.Material.Filled.DeleteForever" OnClick="() => ToggleFileDeleted()"/>
                                    </MudTooltip>
                                }
                            </MudToolBar>
                        </MudPaper>
                    </MudItem>
                }
            </MudGrid>
        </MudTabPanel>
        
        <MudTabPanel Text="Charakterverweise" Icon="@Icons.Material.Filled.AccountCircle" OnClick="() => OpenCharTab()">
            @if (_charApiLoading)
            {
                <LoadingComponent/>
            }
            else
            {
                <MudTextField
                    T="string" @bind-Value="_charSearchString" Placeholder="@Constants.DATAGRID_SEARCHBAR_PLACEHOLDER"
                    Adornment="Adornment.Start" Immediate="true"
                    AdornmentIcon="@Icons.Material.Filled.Search"
                    TextChanged="text => CharSearchTriggered(text)"
                    IconSize="Size.Medium" Class="mt-0"
                    Disabled="@(_model.Deleted ? false : _isLocked)"/>

                <MudPaper Square="true">
                    <MudDropContainer
                        T="CharEntry"
                        ItemDisabled="@(item => !_apiAvailable || _charEntrysUpdating || _isLocked || _model.Deleted)"
                        Items="_filteredCharEntrys"
                        ItemsSelector="@((item, dropzone) => item.DropZoneIdentifier == dropzone)"
                        ItemDropped="CharEntryItemUpdated"
                        Class="d-flex flex-wrap">

                        <ChildContent>
                            <MudPaper Class="ma-4" Width="45%" style="height: 65vh; overflow-y: auto;">
                                <MudList T="string" Class="mud-height-full">
                                    <MudDropZone T="CharEntry" Identifier="@_availableDropzoneIdentifier" Class="mud-height-full">
                                        <MudListSubheader>Verfügbar</MudListSubheader>
                                    </MudDropZone>
                                </MudList>
                            </MudPaper>
                            <MudPaper Class="ma-4" Width="45%" style="height: 65vh; overflow-y: auto;">
                                <MudList T="string" Class="mud-height-full">
                                    <MudDropZone T="CharEntry" Identifier="@_addedDropzoneIdentifier" Class="mud-height-full">
                                        <MudListSubheader>Hinzugefügt</MudListSubheader>
                                    </MudDropZone>
                                </MudList>
                            </MudPaper>
                        </ChildContent>
                        <ItemRenderer>
                            <MudListItem
                                T="string"
                                Disabled="@(!_apiAvailable || _charEntrysUpdating || _isLocked)">
                                @context.FileCharacterEntryDbModel.GetFullDisplayString()
                            </MudListItem>
                        </ItemRenderer>
                    </MudDropContainer>
                </MudPaper>
            }
        </MudTabPanel>
        
        @if (UserAccessService.HasRight(_canViewFileEntrys))
        {
            <MudTabPanel Text="Einträge" Icon="@Icons.Custom.FileFormats.FileDocument" OnClick="() => UnlockCharTab()">
                @if (!_model.Deleted && UserAccessService.HasRight(_canCreateEntrys))
                {
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="ml-auto" OnClick="() => OnClickCreate()">Eintrag hinzufügen</MudButton>
                }
                @if (UserAccessService.HasRight(_canViewFileDeletedEntrys))
                {
                    @if (_showDeletedEntrys)
                    {
                        <MudTooltip Text="Gelöschte Einträge ausblenden" Duration="@Constants.TOOLTIP_DURATION">
                            <MudIconButton Color="Color.Secondary" Icon="@Icons.Material.Filled.Delete" OnClick="() => ToggleShowDeletedEntrys()"/>
                        </MudTooltip>
                    }
                    else
                    {
                        <MudTooltip Text="Gelöschte Einträge anzeigen" Duration="@Constants.TOOLTIP_DURATION">
                            <MudIconButton Color="Color.Secondary" Icon="@Icons.Material.Outlined.Delete" OnClick="() => ToggleShowDeletedEntrys()"/>
                        </MudTooltip>
                    }
                }

                <MudPaper Square="true" style="height: 65vh; overflow-y: auto;">
                    <MudList T="object">
                        @foreach (var entry in _entrys)
                        {
                            if (entry != _entrys.First())
                            {
                                <MudDivider/>
                            }

                            <MudCard>
                                <MudCardHeader>
                                    <CardHeaderContent>
                                        <MudText Typo="Typo.h5">@entry.CreatorAccessModel.Name am @entry.CreatedAtLocal(UserAccessService.GetUserAccess().Result.Settings.TimeZone)</MudText>
                                    </CardHeaderContent>
                                </MudCardHeader>
                                <MudCardContent>
                                    <MudTextField @bind-Value="entry.Content" ReadOnly Variant="Variant.Text" Lines="@_entryLines" AutoGrow MaxLines="10"/>
                                    
                                    @if (UserAccessService.HasRight(_canViewUploadedFilesForEntrys) && entry.FileUploads.Any())
                                    {
                                        <MudTable Items="entry.FileUploads">
                                            <HeaderContent>
                                                <MudTh>Filename</MudTh>
                                                <MudTh Style="width: 350px;">Size</MudTh>
                                                <MudTh Style="width: 350px;">Upload Date</MudTh>
                                                <MudTh Style="width: 200px;">Actions</MudTh>
                                            </HeaderContent>
                                            <RowTemplate>
                                                <MudTd>@context.FileName</MudTd>
                                                <MudTd>@context.SizeText</MudTd>
                                                <MudTd>@context.UploadDateLocal(UserAccessService.GetUserAccess().Result.Settings.TimeZone)</MudTd>
                                                <MudTd>
                                                    <MudButtonGroup Color="Color.Primary" Variant="Variant.Text">
                                                        @if (UserAccessService.HasRight(_canPreviewFilesForEntrys))
                                                        {
                                                            <MudTooltip Text="Datei anschauen" Duration="Constants.TOOLTIP_DURATION">
                                                                <MudIconButton Icon="@Icons.Material.Filled.Preview" Color="Color.Info" OnClick="() => PreviewFile(context)"/>
                                                            </MudTooltip>
                                                        }
                                                        @if (UserAccessService.HasRight(_canDownloadFilesForEntrys))
                                                        {
                                                            <MudTooltip Text="Datei herunterladen" Duration="Constants.TOOLTIP_DURATION">
                                                                <MudIconButton Icon="@Icons.Material.Filled.Download" Color="Color.Tertiary" OnClick="() => DownloadFile(context)"/>
                                                            </MudTooltip>
                                                        }
                                                        @if (!_model.Deleted && UserAccessService.HasRight(_canRenameFilesForEntrys))
                                                        {
                                                            <MudTooltip Text="Dateinamen ändern" Duration="Constants.TOOLTIP_DURATION">
                                                                <MudIconButton Icon="@Icons.Material.Filled.Edit" Color="Color.Primary" OnClick="() => RenameFile(context)"/>
                                                            </MudTooltip>
                                                        }
                                                        @if (!_model.Deleted && UserAccessService.HasRight(_canDeleteFilesForEntrys))
                                                        {
                                                            <MudTooltip Text="Datei löschen" Duration="Constants.TOOLTIP_DURATION">
                                                                <MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Secondary" OnClick="() => DeleteFile(context)"/>
                                                            </MudTooltip>
                                                        }
                                                    </MudButtonGroup>
                                                </MudTd>
                                            </RowTemplate>
                                        </MudTable>
                                    }
                                </MudCardContent>
                                <MudCardActions>
                                    <div class="d-flex align-center justify-space-between" style="width: 100%;">
                                        <MudText Style="opacity: 0.2" Typo="Typo.body2">@GetSublineText(entry)</MudText>
                                        <MudButtonGroup Color="Color.Primary" Variant="Variant.Text">
                                            @if (!_model.Deleted && UserAccessService.HasRight(_canUploadFilesForEntrys))
                                            {
                                                <MudFileUpload T="IBrowserFile" FilesChanged="(file) => UploadFiles(file, entry)" Accept="application/pdf, image/png, image/jpg, image/jpeg">
                                                    <ActivatorContent>
                                                        <MudTooltip Text="Datei hochladen" Duration="Constants.TOOLTIP_DURATION">
                                                            <MudIconButton Icon="@Icons.Material.Filled.CloudUpload" Color="Color.Tertiary"/>
                                                        </MudTooltip>
                                                    </ActivatorContent>
                                                </MudFileUpload>
                                            }
                                            @if (!_model.Deleted && UserAccessService.HasRight(_canEditEntrys))
                                            {
                                                <MudTooltip Text="Eintrag bearbeiten" Duration="Constants.TOOLTIP_DURATION">
                                                    <MudIconButton Variant="Variant.Text" Color="Color.Primary" Icon="@Icons.Material.Filled.Edit" OnClick="() => EditEntry(entry)"/>
                                                </MudTooltip>
                                            }
                                            @if (!_model.Deleted && !entry.Deleted && UserAccessService.HasRight(_canDeleteEntrys))
                                            {
                                                <MudTooltip Text="Eintrag löschen" Duration="Constants.TOOLTIP_DURATION">
                                                    <MudIconButton Variant="Variant.Text" Color="Color.Error" Icon="@Icons.Material.Filled.DeleteForever" OnClick="() => RemoveEntry(entry)"/>
                                                </MudTooltip>
                                            }
                                            else if (!_model.Deleted && entry.Deleted && UserAccessService.HasRight(_canRestoreEntrys))
                                            {
                                                <MudTooltip Text="Eintrag wiederherstellen" Duration="Constants.TOOLTIP_DURATION">
                                                    <MudIconButton Variant="Variant.Text" Color="Color.Success" Icon="@Icons.Material.Filled.RestoreFromTrash" OnClick="() => RestoreEntry(entry)"/>
                                                </MudTooltip>
                                            }
                                        </MudButtonGroup>
                                    </div>
                                </MudCardActions>
                            </MudCard>
                        }
                    </MudList>
                </MudPaper>
            </MudTabPanel>
        }
        
        @if (UserAccessService.HasRight(_canViewLogs))
        {
            <MudTabPanel Text="Logs" Icon="@Icons.Material.Filled.ScreenSearchDesktop" OnClick="() => UnlockCharTab()">
                <MudDataGrid
                    T="FileLogsDbModel" MultiSelection="true"
                    Items="@_logs" SortMode="SortMode.Multiple" Filterable="true"
                    QuickFilter="@QuickFilter" RowClick="OpenLogContent"
                    Hideable="true" Hover="true" Striped="true" FixedHeader="true" Height="55vh">
                    <ToolBarContent>
                        <MudText Typo="Typo.h6">Logs für @_model.Id</MudText>
                        <MudSpacer />
                        <MudTextField
                            T="string" @bind-Value="_logSearchString" Placeholder="@Constants.DATAGRID_SEARCHBAR_PLACEHOLDER"
                            Adornment="Adornment.Start" Immediate="true"
                            AdornmentIcon="@Icons.Material.Filled.Search"
                            IconSize="Size.Medium" Class="mt-0"/>
                    </ToolBarContent>
                    <Columns>
                        <PropertyColumn Hideable="false" Property="x => x.Id" Title="#" Filterable="false" />
                        <PropertyColumn Hideable="false" Property="x => x.Content" Title="Information" />
                        <PropertyColumn Hideable="false" Property="x => x.AccessModel.Name" Title="Ersteller" />
                        <PropertyColumn Hideable="false" Property="x => x.AccessId" Title="ErstellerId" />
                        <PropertyColumn Hideable="false" Property="x => x.Type" Title="Type" />
                        <TemplateColumn Hideable="false" Sortable="true" Filterable="true" Title="Datum">
                            <CellTemplate>
                                @context.Item.CreatedAtLocal(UserAccessService.GetUserAccess().Result.Settings.TimeZone)
                            </CellTemplate>
                        </TemplateColumn>
                    </Columns>
                    <PagerContent>
                        <MudDataGridPager T="FileLogsDbModel" />
                    </PagerContent>
                </MudDataGrid>
            </MudTabPanel>
        }
    </MudTabs>
    
    <FileUploadPreview @ref="_fileUploadPreview" Model="_model" HubConnection="_hubConnection" />
    
    @if (_isCurrentTabCharEntrys && _lockedByUser is not null && _lockedByUser.Id != UserAccessService.GetUserAccess().Result.Id)
    {
        <MudAlert Severity="Severity.Info" Style="position: absolute; top: 5rem; right: 31px">
            Derzeit wird die Maske von [@_lockedByUser.Id] @_lockedByUser.Name bearbeitet!
        </MudAlert>
    }
}
else
{
    <ErrorComponent/>
}

@code {
    [CascadingParameter] public UserAccessService UserAccessService { get; set; }
    [Parameter] public string Id { get; set; }
    private HubConnection? _hubConnection;
    private bool _loading = true;

    private bool _hasNeededRank;

    private bool _rightsSetted;
    private RightEnum _canViewFileActions;
    private RightEnum _canEditTitle;
    private RightEnum _canEditDescription;
    private RightEnum _canEditStatus;
    private RightEnum _canEditMinRank;
    private RightEnum _canEditCategory;
    private RightEnum _canDeleteFile;
    private RightEnum _canRestoreFile;
    private RightEnum _canViewLogs;
    private RightEnum _canViewFileEntrys;
    private RightEnum _canViewFileDeletedEntrys;
    private RightEnum _canCreateEntrys;
    private RightEnum _canEditEntrys;
    private RightEnum _canDeleteEntrys;
    private RightEnum _canRestoreEntrys;
    private RightEnum _canViewUploadedFilesForEntrys;
    private RightEnum _canUploadFilesForEntrys;
    private RightEnum _canDownloadFilesForEntrys;
    private RightEnum _canDeleteFilesForEntrys;
    private RightEnum _canRenameFilesForEntrys;
    private RightEnum _canPreviewFilesForEntrys;
    
    private FileDbModel? _model;
    private FileDbModel? _checkModel;
    private List<FileLogsDbModel> _logs = [];
    private List<FileEntryDbModel> _entrys = [];
    private List<CharEntry> _charEntrys = [];
    private List<CharEntry> _filteredCharEntrys = [];
    private bool _apiAvailable = false;
    private bool _charEntrysUpdating = false;
    private string? _charSearchString;
    private bool _isLocked;
    private AccessDbModel? _lockedByUser;
    private bool _isCurrentTabCharEntrys = false;
    private bool _charApiLoading = true;
    private string _availableDropzoneIdentifier = "available";
    private string _addedDropzoneIdentifier = "added";
    
    private List<FileCategoryDbModel> _categoryDbModels = [];
    
    private class CharEntry(FileCharacterEntryDbModel fileCharacterEntryDbModel, bool isAdded, string dropZoneIdentifier)
    {
        public FileCharacterEntryDbModel FileCharacterEntryDbModel { get; } = fileCharacterEntryDbModel;
        public bool IsAdded { get; set; } = isAdded;
        public string DropZoneIdentifier { get; set; } = dropZoneIdentifier;
    }
    
    private static string _dividerStyle = "margin: 10px 0; opacity: 0;";

    private string GetFileTitle()
    {
        if (_checkModel is null)
        {
            return "Loading...";
        }

        return _checkModel.Type switch
        {
            FileTypeEnum.Supportfile => "Supportakte " + _checkModel.Title,
            FileTypeEnum.Groupingfile => "Gruppierungsakte " + _checkModel.Title,
            _ => _checkModel.Title
        };
    }

    private const int _entryLines = 3;
    private bool _showDeletedEntrys = false;
    
    private string? _logSearchString;
    
    private FileUploadPreview? _fileUploadPreview;

    private void CharSearchTriggered(string text)
    {
        if (string.IsNullOrEmpty(text))
        {
            _filteredCharEntrys = _charEntrys;
            return;
        }
        
        _filteredCharEntrys = _charEntrys.Where(x => x.FileCharacterEntryDbModel.GetFullDisplayString().Contains(text)).ToList();
    }
    
    private async Task CharEntryItemUpdated(MudItemDropInfo<CharEntry> dropItem)
    {
        if (dropItem.Item is null) return;
        if (dropItem.Item.DropZoneIdentifier == dropItem.DropzoneIdentifier) return;
        if (_hubConnection is null) return;
        if (_model is null) return;
        if (_model.Deleted) return;
        
        var access = await UserAccessService.GetUserAccess();
        
        dropItem.Item.DropZoneIdentifier = dropItem.DropzoneIdentifier;
        dropItem.Item.IsAdded = !dropItem.Item.IsAdded;
        
        _charEntrysUpdating = true;
        StateHasChanged();
        
        if (dropItem.Item.IsAdded)
        {
            var isAdded = await FileProxy.AddCharEntryAsync(dropItem.Item.FileCharacterEntryDbModel, access.Id);
            if (!isAdded)
            {
                Snackbar.Add($"{dropItem.Item.FileCharacterEntryDbModel.GetFullDisplayString()} konnte nicht hinzugefügt werden.", Severity.Error);
            }
            else
            {
                Snackbar.Add($"{dropItem.Item.FileCharacterEntryDbModel.GetFullDisplayString()} zu Supportakte hinzugefügt.", Severity.Success);
                await _hubConnection.SendAsync(FileHubMethodEnum.UpdateFile.ToString(), _model.Id);
            }
        }
        else
        {
            var isRemoved = await FileProxy.RemoveCharEntryAsync(dropItem.Item.FileCharacterEntryDbModel, access.Id);
            if (!isRemoved)
            {
                Snackbar.Add($"{dropItem.Item.FileCharacterEntryDbModel.GetFullDisplayString()} konnte nicht entfernt werden.", Severity.Error);
            }
            else
            {
                Snackbar.Add($"{dropItem.Item.FileCharacterEntryDbModel.GetFullDisplayString()} von Supportakte entfernt.", Severity.Success);
                await _hubConnection.SendAsync(FileHubMethodEnum.UpdateFile.ToString(), _model.Id);
            }
        }
        
        _charEntrysUpdating = false;
        StateHasChanged();
    }
    
    private async Task UploadFiles(IBrowserFile? file, FileEntryDbModel entryDbModel)
    {
        if (_model is null) return;
        if (_model.Deleted) return;
        if (_hubConnection is null) return;
        if (_fileUploadPreview is null) return;
        if (file is null) return;

        var maxFileSize = FileEntryProxy.GetMaxFileSize();
        if (file.Size > maxFileSize)
        {
            Snackbar.Add("Datei ist zu groß!", Severity.Error);
            return;
        }
        
        try
        {
            var fileDbModel = await GetFileUploadDbModel(file, entryDbModel);
            if (fileDbModel is null)
            {
                Snackbar.Add($"Dateiformat [{file.ContentType}] wird nicht unterstützt.", Severity.Error);
                return;
            }
            
            _fileUploadPreview.OpenFile(fileDbModel, true);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Fehler beim Hochladen der Datei: {ex.Message}", Severity.Error);
        }
    }

    private async Task<FileUploadDbModel?> GetFileUploadDbModel(IBrowserFile file, FileEntryDbModel entryDbModel)
    {
        var maxFileSize = FileEntryProxy.GetMaxFileSize();
        
        // should outsource the contentType in a enum, but i'm to lazy rn
        switch (file.ContentType)
        {
            case "image/png":
            case "image/jpeg":
            case "image/jpg":
            {
                var resizedFile = await file.RequestImageFileAsync(file.ContentType, 800, 600);
                using var stream = resizedFile.OpenReadStream(maxFileSize);

                using var memoryStream = new MemoryStream();
                await stream.CopyToAsync(memoryStream);
                var buffer = memoryStream.ToArray(); 
        
                return new FileUploadDbModel(entryDbModel.Id, file.Name, file.ContentType, buffer);
            }
            case "application/pdf":
            {
                using var stream = file.OpenReadStream(maxFileSize);
                using var memoryStream = new MemoryStream();
                await stream.CopyToAsync(memoryStream);
                var buffer = memoryStream.ToArray();
                
                return new FileUploadDbModel(entryDbModel.Id, file.Name, file.ContentType, buffer);
            }
            default:
                return null;
        }
    }

    private async Task DeleteFile(FileUploadDbModel file)
    {
        if (_model is null) return;
        if (_model.Deleted) return;
        if (_fileUploadPreview is null) return;
        await _fileUploadPreview.DeleteFile(file);
    }
    
    private async Task DownloadFile(FileUploadDbModel file)
    {
        if (_fileUploadPreview is null) return;
        await _fileUploadPreview.DownloadFile(file);
    }

    private async Task RenameFile(FileUploadDbModel file)
    {
        if (_model is null) return;
        if (_model.Deleted) return;
        if (_fileUploadPreview is null) return;
        await _fileUploadPreview.RenameFile(file);
    }

    private void PreviewFile(FileUploadDbModel file)
    {
        _fileUploadPreview?.OpenFile(file, false);
    }

    public async Task StartAsync()
    {
        await StartHubConnection();
        await Load();

        ReloadService.OnCustomReload += Load;
    }
    
    public async ValueTask DisposeAsync()
    {
        ReloadService.OnCustomReload -= Load;
        
        if (_hubConnection is null) return;
 
        await UnlockCharTab();
        await _hubConnection.DisposeAsync();
    }

    private async Task Load()
    {
        await LoadCategories();
        
        await LoadModel();

        await LoadCharEntrys();
        
        StateHasChanged();
    }

    private async Task LoadCategories()
    {
        _categoryDbModels = await FileCategoryProxy.GetAllAsync();
        StateHasChanged();
    }
    
    private async Task LoadModel()
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        
        if (!Ulid.TryParse(Id, out var fileId))
        {
            Snackbar.Add("Parsing failed", Severity.Error);
            _loading = false;
            return;
        }
        
        var model = await FileProxy.GetFullAsync(fileId);
        if (model is null)
        {
            Snackbar.Add("Ein Fehler beim Laden ist aufgetreten.", Severity.Error);
            _loading = false;
            return;
        }

        if (access.Rank < model.MinRank)
        {
            Navigation.NavigateToNotAuthorized();
            return;
        }

        _hasNeededRank = true;

        _model = model;
        _checkModel = _model.CreateShallowCopy();

        SetRights();
        
        @if (await UserAccessService.HasRightAsync(RightEnum.ViewSupportfileEntrys))
        {
            _entrys = _showDeletedEntrys ?
                _model.Entrys
                    .OrderByDescending(x => x.Id)
                    .ToList() :
                _model.Entrys
                    .Where(x => !x.Deleted)
                    .OrderByDescending(x => x.Id)
                    .ToList();
        }
        
        @if (await UserAccessService.HasRightAsync(RightEnum.SupportfileViewLogs))
        {
            _logs = _model.Logs
                .OrderByDescending(x => x.Id)
                .ToList();;
        }
        
        _loading = false;
        StateHasChanged();
    }

    private void SetRights()
    {
        if (_model is null) return;
        
        if (_model.Type == FileTypeEnum.Supportfile)
        {
            _canViewFileActions = RightEnum.SupportfileActions;
            _canEditTitle = RightEnum.SupportfileEditTitle;
            _canEditDescription = RightEnum.SupportfileEditDescription;
            _canEditStatus = RightEnum.SupportfileEditStatus;
            _canEditMinRank = RightEnum.SupportfileEditMinRank;
            _canEditCategory = RightEnum.SupportfileEditCategory;
            _canDeleteFile = RightEnum.SupportfileDelete;
            _canRestoreFile = RightEnum.SupportfileRestore;
            _canViewLogs = RightEnum.SupportfileViewLogs;
            _canViewFileEntrys = RightEnum.ViewSupportfileEntrys;
            _canViewFileDeletedEntrys = RightEnum.ViewSupportfileDeletedEntrys;
            _canCreateEntrys = RightEnum.SupportfileCreateEntrys;
            _canEditEntrys = RightEnum.SupportfileEditEntrys;
            _canDeleteEntrys = RightEnum.SupportfileDeleteEntrys;
            _canRestoreEntrys = RightEnum.SupportfileRestoreEntrys;
            _canViewUploadedFilesForEntrys = RightEnum.ViewSupportUploadedFilesForEntrys;
            _canUploadFilesForEntrys = RightEnum.SupportfileUploadFileForEntry;
            _canDownloadFilesForEntrys = RightEnum.SupportfileDownloadFileForEntry;
            _canDeleteFilesForEntrys = RightEnum.SupportfileDeleteFileForEntry;
            _canRenameFilesForEntrys = RightEnum.SupportfileRenameFileForEntry;
            _canPreviewFilesForEntrys = RightEnum.SupportfilePreviewFileForEntry;
        }
        else if (_model.Type == FileTypeEnum.Groupingfile)
        {
            _canViewFileActions = RightEnum.GroupingfileActions;
            _canEditTitle = RightEnum.GroupingfileEditTitle;
            _canEditDescription = RightEnum.GroupingfileEditDescription;
            _canEditStatus = RightEnum.GroupingfileEditStatus;
            _canEditMinRank = RightEnum.GroupingfileEditMinRank;
            _canEditCategory = RightEnum.GroupingfileEditCategory;
            _canDeleteFile = RightEnum.GroupingfileDelete;
            _canRestoreFile = RightEnum.GroupingfileRestore;
            _canViewLogs = RightEnum.GroupingfileViewLogs;
            _canViewFileEntrys = RightEnum.ViewGroupingfileEntrys;
            _canViewFileDeletedEntrys = RightEnum.ViewGroupingfileDeletedEntrys;
            _canCreateEntrys = RightEnum.GroupingfileCreateEntrys;
            _canEditEntrys = RightEnum.GroupingfileEditEntrys;
            _canDeleteEntrys = RightEnum.GroupingfileDeleteEntrys;
            _canRestoreEntrys = RightEnum.GroupingfileRestoreEntrys;
            _canViewUploadedFilesForEntrys = RightEnum.ViewGroupingUploadedFilesForEntrys;
            _canUploadFilesForEntrys = RightEnum.GroupingfileUploadFileForEntry;
            _canDownloadFilesForEntrys = RightEnum.GroupingfileDownloadFileForEntry;
            _canDeleteFilesForEntrys = RightEnum.GroupingfileDeleteFileForEntry;
            _canRenameFilesForEntrys = RightEnum.GroupingfileRenameFileForEntry;
            _canPreviewFilesForEntrys = RightEnum.GroupingfilePreviewFileForEntry;
        }

        _rightsSetted = true;
    }
    
    private async Task LoadCharEntrys()
    {
        if (_model is null) return;
        _charApiLoading = true;

        _charEntrys = _model.CharacterEntrys.Select(x => new CharEntry(x, true, _addedDropzoneIdentifier)).ToList();
        var addedCharIds = _model.CharacterEntrys.Select(x => x.CharacterId);

        try
        {
            var accountResponse = await AccountApi.GetAllAsync();
            var characterResponse = await CharacterApi.GetAllAsync();
            if (characterResponse.IsSuccessStatusCode && accountResponse.IsSuccessStatusCode)
            {
                var allChars = characterResponse.Content;
                var allAccount = accountResponse.Content;

                foreach (var characterApiModel in allChars.Where(x => !addedCharIds.Contains(x.Id)))
                {
                    var account = allAccount.FirstOrDefault(x => x.Id == characterApiModel.AccountId);
                    var charEntry = new FileCharacterEntryDbModel(_model.Id, characterApiModel.AccountId, characterApiModel.Id, account!.DiscordId, account.Name, characterApiModel.FirstName, characterApiModel.LastName);

                    _charEntrys.Add(new CharEntry(charEntry, false, _availableDropzoneIdentifier));
                }

                _apiAvailable = true;
            }
            else
            {
                if (!characterResponse.IsSuccessStatusCode)
                {
                    Snackbar.Add(characterResponse.Error.Message, Severity.Error);
                }

                if (!accountResponse.IsSuccessStatusCode)
                {
                    Snackbar.Add(accountResponse.Error.Message, Severity.Error);
                }
                _apiAvailable = false;
            }
        }
        catch (HttpRequestException ex)
        {
            Snackbar.Add(Constants.API_ERROR_NOT_AVAILABLE, Severity.Error);
            _apiAvailable = false;
        }
        catch (Exception ex)
        {
            Snackbar.Add(ex.Message, Severity.Error);
            _apiAvailable = false;
        }

        _charApiLoading = false;
        _filteredCharEntrys = _charEntrys;
        StateHasChanged();
    }

    private async Task OnClickCreate()
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        if (_model is null) return;
        if (_model.Deleted) return;
        if (!await UserAccessService.HasRightAsync(_canCreateEntrys)) return;
        
        var inputs = new List<InputModel>
        {
            new(
                InputTypes.Text,
                "Nachricht/Information",
                string.Empty,
                "Am... Mit... Beschlossen...",
                _entryLines
            ),
        };

        var dialogData = await DialogService.OpenDialog(
            "Eintrag hinzufügen", 
            "Welche Information möchtest du hinzufügen?", 
            "Eintrag hinzufügen",
            inputs);
        if (dialogData is null) return;
        
        var (validated, message) = dialogData[0].ValidateInput<string>();
        if (!validated)
        {
            Snackbar.Add("Es wurde keine Nachricht eingetragen!", Severity.Error);
            return;
        }

        var response = await FileEntryProxy.AddEntryAsync(new FileEntryDbModel(_model.Id, message!, access.Id));
        if (response is null)
        {
            Snackbar.Add("Nachricht konnte nicht hinzugefügt werden!", Severity.Error);
            return;
        }

        await SendUpdateEntryToHub();
    }

    private async Task StartHubConnection()
    {
        _hubConnection = HubHelper.GetHubConnection(Navigation, FileHub.HubPattern);
        
        _hubConnection.On<Ulid>(FileHubMethodEnum.UpdateFile.ToString(), async (id) =>
        {
            if (_model is null) return;
            if (id != _model.Id) return;
            
            await InvokeAsync(Load);
            await InvokeAsync(StateHasChanged);
        });
        
        _hubConnection.On<Ulid>(FileHubMethodEnum.UpdateEntrys.ToString(), async (id) =>
        {
            if (_model is null) return;
            if (id != _model.Id) return;
            
            await InvokeAsync(Load);
            await InvokeAsync(StateHasChanged);
        });
        
        _hubConnection.On<Ulid>(FileHubMethodEnum.ToggleFileDeleted.ToString(), async (id) =>
        {
            if (_model is null) return;
            if (id != _model.Id) return;

            if (!_model.Deleted)
            {
                switch (_model.Type)
                {
                    case FileTypeEnum.Supportfile:
                        Navigation.NavigateTo(SupportfileOverview.GetRedirectUrl());
                        break;
                    case FileTypeEnum.Groupingfile:
                        Navigation.NavigateTo(GroupingfileOverview.GetRedirectUrl());
                        break;
                }
                return;
            }

            await InvokeAsync(Load);
            await InvokeAsync(StateHasChanged);
        });
        
        _hubConnection.On<Ulid, Ulid>(FileHubMethodEnum.FileLocked.ToString(), async (fileId, userId) =>
        {
            if (_model is null) return;
            if (fileId != _model.Id) return;

            _isLocked = true;

            try
            {
                var user = await AccessProxy.GetAsync(userId);
                _lockedByUser = user;
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"Exception: {ex.Message}");
            }

            await InvokeAsync(StateHasChanged);
        });

        _hubConnection.On<Ulid, Ulid>(FileHubMethodEnum.FileUnlocked.ToString(), async (fileId, userId) =>
        {
            if (_model is null) return;
            if (fileId != _model.Id) return;

            _isLocked = false;
            _lockedByUser = null;
            await InvokeAsync(StateHasChanged);

            if (!_isCurrentTabCharEntrys) return;

            await InvokeAsync(LockCharTabAsync);
        });
        
        await _hubConnection.StartAsync();
        
        if (_model is null) return;
        
        _isLocked = await GetLockCharTabAsync();
        if (_isLocked)
        {
            var lockedByUserId = await _hubConnection.InvokeAsync<Ulid>(FileHubMethodEnum.GetLockedByUser.ToString(), _model.Id);
            _lockedByUser = await AccessProxy.GetAsync(lockedByUserId);
        }
    }

    private async Task OpenCharTab()
    {
        if (_isCurrentTabCharEntrys) return;
        _isCurrentTabCharEntrys = true;
        if (_model is null) return;
        if (_hubConnection is null) return;

        _isLocked = await GetLockCharTabAsync();
        if (_isLocked)
        {
            var lockedByUserId = await _hubConnection.InvokeAsync<Ulid>(FileHubMethodEnum.GetLockedByUser.ToString(), _model.Id);
            _lockedByUser = await AccessProxy.GetAsync(lockedByUserId);
            return;
        }

        await LockCharTabAsync();
    }

    private async Task<bool> GetLockCharTabAsync()
    {
        if (_model is null) return false;
        if (_hubConnection is null) return false;
        
        return await _hubConnection.InvokeAsync<bool>(FileHubMethodEnum.IsFileLocked.ToString(), _model.Id);
    }
    
    private async Task LockCharTabAsync()
    {
        if (_model is null) return;
        if (_hubConnection is null) return;
        
        try
        {
            var access = await UserAccessService.GetUserAccess();

            await _hubConnection.InvokeAsync(FileHubMethodEnum.LockFile.ToString(), _model.Id, access.Id);
            _lockedByUser = access;
        }
        catch (HubException ex)
        {
            Console.Error.WriteLine($"HubException: {ex.Message}");
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Exception: {ex.Message}");
        }
    }

    private async Task UnlockCharTab()
    {
        _isCurrentTabCharEntrys = false;
        if (_isLocked) return;
        
        if (_model is null) return;
        if (_hubConnection is null) return;
        
        var access = await UserAccessService.GetUserAccess();

        if (_lockedByUser?.Id != access.Id) return;
        
        await _hubConnection.InvokeAsync(FileHubMethodEnum.UnlockFile.ToString(), _model.Id, access.Id);
        _lockedByUser = null;
    }
    
    private async Task SendUpdateEntryToHub()
    {
        if (_model is null) return;
        if (_hubConnection is null) return;
        
        await _hubConnection.SendAsync(FileHubMethodEnum.UpdateEntrys.ToString(), _model.Id);
    }
    
    private async Task EditEntry(FileEntryDbModel entry)
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        if (_model is null) return;
        if (_model.Deleted) return;
        if (!await UserAccessService.HasRightAsync(_canEditEntrys)) return;
        
        const string title = "Eintrag bearbeiten";
        var description = "Wie möchtest du den Eintrag bearbeiten?";
        const string submitButtonText = "Eintrag bearbeitet";

        const string messageLabel = "Nachricht/Information";

        var inputs = new List<InputModel>
        {
            new(
                InputTypes.Text,
                messageLabel,
                entry.Content,
                "Am... Mit... Beschlossen...",
                _entryLines
            ),
        };

        var parameter = new DialogParameters<SimpleMudDialog>
        {
            { x => x.Description, description },
            { x => x.Inputs, inputs },
            { x => x.SubmitButtonText, submitButtonText },
        };

        var dialog = await DialogService.ShowAsync<SimpleMudDialog>(title, parameter, new DialogOptions { FullWidth = true });
        var dialogResult = await dialog.Result;

        if (dialogResult != null && dialogResult.Canceled) return;

        var data = (List<InputModel>)dialogResult.Data!;
        var message = data.First(x => x.Label == messageLabel).Value;

        if (string.IsNullOrEmpty(message))
        {
            Snackbar.Add("Es wurde keine Nachricht eingetragen!", Severity.Error);
            return;
        }

        var response = await FileEntryProxy.UpdateEntryContentAsync(entry.Id, message, access.Id);
        if (!response)
        {
            Snackbar.Add("Nachricht konnte nicht bearbeitet werden!", Severity.Error);
            return;
        }

        await SendUpdateEntryToHub();
    }

    private async Task RemoveEntry(FileEntryDbModel entry)
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        if (_model is null) return;
        if (_model.Deleted) return;
        if (!await UserAccessService.HasRightAsync(_canDeleteEntrys)) return;
        
        var result = await DialogService.ShowMessageBox(
            "Eintrag löschen", 
            "Bist du dir sicher diesen Eintrag zu löschen? Dies kann nicht mehr rückgängig gemacht werden!", 
            yesText:"Löschen!", cancelText:"Abbrechen"
        );

        if (result is null or false) return;

        var response = await FileEntryProxy.RemoveEntryAsync(entry.Id, access.Id);
        if (!response)
        {
            Snackbar.Add("Dieser Eintrag konnte nicht gelöscht werden!");
            return;
        }
        
        await SendUpdateEntryToHub();
    }

    private async Task RestoreEntry(FileEntryDbModel entry)
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        if (_model is null) return;
        if (_model.Deleted) return;
        if (!await UserAccessService.HasRightAsync(_canDeleteEntrys)) return;
        
        var result = await DialogService.ShowMessageBox(
            "Eintrag wiederherstellen", 
            "Bist du dir sicher diesen Eintrag zu wiederherzustellen?", 
            yesText:"Wiederherstellen!", cancelText:"Abbrechen"
        );

        if (result is null or false) return;

        var response = await FileEntryProxy.RestoreEntryAsync(entry.Id, access.Id);
        if (!response)
        {
            Snackbar.Add("Dieser Eintrag konnte nicht gelöscht werden!");
            return;
        }
        
        await SendUpdateEntryToHub();
    }


    private string GetSublineText(FileEntryDbModel entry)
    {
        return $"{entry.Id}" + (entry.CreatedAtLocal() != entry.ModifiedAtLocal() ? $" - geändert {entry.ModifiedAtLocal(UserAccessService.GetUserAccess().Result.Settings.TimeZone)}" : string.Empty);
    }
    
    private Func<FileLogsDbModel, bool> QuickFilter => x =>
    {
        if (_logSearchString == null) return true;
        
        var lowerSearchString = _logSearchString.ToLower();
        
        if (string.IsNullOrWhiteSpace(lowerSearchString))
            return true;

        if (x.Content.ToLower().Contains(lowerSearchString, StringComparison.OrdinalIgnoreCase))
            return true;

        if (x.Type.ToString().ToLower().Contains(lowerSearchString, StringComparison.OrdinalIgnoreCase))
            return true;
        
        if (x.CreatedAtLocal(UserAccessService.GetUserAccess().Result.Settings.TimeZone).ToLower().Contains(lowerSearchString, StringComparison.OrdinalIgnoreCase))
            return true;
        
        if ($"{x.Id}".ToLower().Contains(lowerSearchString))
            return true;

        return false;
    };

    private async Task ToggleFileDeleted()
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        if (_model is null) return;
        if (_hubConnection is null) return;

        if (_model.Deleted && !await UserAccessService.HasRightAsync(_canRestoreFile)) return;
        if (!_model.Deleted && !await UserAccessService.HasRightAsync(_canDeleteFile)) return;

        var title = _model.Deleted ? "Supportakte wiederherstellen" : "Supportakte löschen";
        var message = _model.Deleted ? 
            "Bist du dir sicher diese Supportakte wiederherzustellen?" : 
            "Bist du dir sicher diese Supportakte zu löschen? Dies kann nicht mehr rückgängig gemacht werden!";
        var yesText = _model.Deleted ? "Wiederherstellen" : "Löschen";
        
        var result = await DialogService.ShowMessageBox(
            title, 
            message, 
            yesText:yesText, cancelText:"Abbrechen"
        );

        if (result is null or false) return;

        var response = await FileProxy.ToggleDeletedAsync(_model.Id, access.Id);
        if (!response)
        {
            Snackbar.Add("Dieser Supportakte konnte nicht gelöscht/wiederhergestellt werden!");
            return;
        }
        
        await _hubConnection.SendAsync(FileHubMethodEnum.ToggleFileDeleted.ToString(), _model.Id);
    }

    private async Task SaveChanges()
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        if (_model is null) return;
        if (_model.Deleted) return;
        if (_hubConnection is null) return; 
        
        if (_model is null || _checkModel is null || access is null)
        {
            Snackbar.Add("Mögliche Änderungen konnte nicht aktualisiert werden.", Severity.Error);
            return;
        }

        var shouldReload = false;
        
        if (_checkModel.Title != _model.Title && await UserAccessService.HasRightAsync(_canEditTitle))
        {
            var updateResponse = await FileProxy.UpdateTitleAsync(_model.Id, _model.Title, access.Id);
            if (!updateResponse)
            {
                Snackbar.Add("Title konnte nicht aktualisiert werden.", Severity.Error);
            }
            else
            {
                Snackbar.Add("Title wurde aktualisiert.", Severity.Success);
                shouldReload = true;
            }
        }
        
        if (_checkModel.Description != _model.Description && await UserAccessService.HasRightAsync(_canEditDescription))
        {
            var updateResponse = await FileProxy.UpdateDescriptionAsync(_model.Id, _model.Description, access.Id);
            if (!updateResponse)
            {
                Snackbar.Add("Description konnte nicht aktualisiert werden.", Severity.Error);
            }
            else
            {
                Snackbar.Add("Description wurde aktualisiert.", Severity.Success);
                shouldReload = true;
            }
        }
        
        if (_checkModel.Status != _model.Status && await UserAccessService.HasRightAsync(_canEditStatus))
        {
            var updateResponse = await FileProxy.UpdateStatusAsync(_model.Id, _model.Status, access.Id);
            if (!updateResponse)
            {
                Snackbar.Add("Status konnte nicht aktualisiert werden.", Severity.Error);
            }
            else
            {
                Snackbar.Add("Status wurde aktualisiert.", Severity.Success);
                shouldReload = true;
            }
        }
        
        if (_checkModel.MinRank != _model.MinRank && await UserAccessService.HasRightAsync(_canEditMinRank))
        {
            var updateResponse = await FileProxy.UpdateMinRankAsync(_model.Id, _model.MinRank, access.Id);
            if (!updateResponse)
            {
                Snackbar.Add("MinRank konnte nicht aktualisiert werden.", Severity.Error);
            }
            else
            {
                Snackbar.Add("MinRank wurde aktualisiert.", Severity.Success);
                shouldReload = true;
            }
        }
        
        if (_checkModel.CategoryId != _model.CategoryId && await UserAccessService.HasRightAsync(_canEditCategory))
        {
            var updateResponse = await FileProxy.ChangeCategoryAsync(_model.Id, _model.CategoryId, access.Id);
            if (!updateResponse)
            {
                Snackbar.Add("Kategorie konnte nicht aktualisiert werden.", Severity.Error);
            }
            else
            {
                Snackbar.Add("Kategorie wurde aktualisiert.", Severity.Success);
                shouldReload = true;
            }
        }

        if (!shouldReload) return;
        
        await _hubConnection.SendAsync(FileHubMethodEnum.UpdateFile.ToString(), _model.Id);
    }

    private async Task ToggleShowDeletedEntrys()
    {
        _showDeletedEntrys = !_showDeletedEntrys;

        await Load();
    }

    private async Task OpenLogContent(DataGridRowClickEventArgs<FileLogsDbModel> args)
    {
        var log = args.Item;
        
        await DialogService.OpenDialogAsync(log.Id, log.CreatedAt, log.Content);
    }
}
