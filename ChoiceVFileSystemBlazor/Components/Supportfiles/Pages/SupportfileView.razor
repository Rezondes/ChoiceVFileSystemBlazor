@page "/supportfiles/view/{id}"

@implements IAsyncDisposable

@code {
    public const string Url = "/supportfiles/view/";
    public static string GetRedirectUrl(string id) => Url + id;
}

<PageTitle>@(GetSupportfileTitle())</PageTitle>

@if (_loading || _hubConnection is null || !_isAuthorized || !_hasNeededRank || _model is null)
{
    <PageLoading/>
}
else if (_model is not null)
{
    <h1>@(GetSupportfileTitle())</h1>
    <MudTabs Elevation="2" Rounded="true" ApplyEffectsToContainer="true" PanelClass="pa-6" Style="height: 90%">
        <MudTabPanel Text="Allgemein" Icon="@Icons.Material.Filled.Info" OnClick="() => UnlockCharTab()">
            <MudGrid Justify="Justify.FlexStart">
                <MudItem xs="8">
                    <MudPaper Class="pa-4">
                        <MudTextField Label="Ersteller" Variant="Variant.Outlined" ReadOnly Value="@_model.CreatorAccessModel.Name"/>
                        
                        <MudDivider Style="@_dividerStyle"/>
                        <MudTextField Label="Erstellt am" Variant="Variant.Outlined" ReadOnly Value="@_model.CreatedAtLocal()"/>

                        <MudDivider Style="@_dividerStyle"/>
                        <MudTextField Label="Titel" Variant="Variant.Outlined" ReadOnly="@(_model.Deleted || !UserAccessService.HasRight(RightEnum.SupportfileEditTitle))" @bind-Value="_model.Title"/>

                        <MudDivider Style="@_dividerStyle"/>
                        <MudTextField Label="Beschreibung" Lines="3" Variant="Variant.Outlined" ReadOnly="@(_model.Deleted || !UserAccessService.HasRight(RightEnum.SupportfileEditDescription))" @bind-Value="_model.Description"/>

                        <MudDivider Style="@_dividerStyle"/>
                        <MudSelect T="FileStatusEnum" Label="Status" Variant="Variant.Outlined" ReadOnly="@(_model.Deleted || !UserAccessService.HasRight(RightEnum.SupportfileEditStatus))" @bind-Value="_model.Status">
                            @foreach (FileStatusEnum status in Enum.GetValues(typeof(FileStatusEnum)))
                            {
                                <MudSelectItem Value="@(status)"/>
                            }
                        </MudSelect>

                        <MudDivider Style="@_dividerStyle"/>
                        <MudSelect T="RankEnum" Label="MinRank" Variant="Variant.Outlined" ReadOnly="@(_model.Deleted || !UserAccessService.HasRight(RightEnum.SupportfileEditMinRank))" @bind-Value="_model.MinRank">
                            @foreach (RankEnum status in Enum.GetValues(typeof(RankEnum)))
                            {
                                <MudSelectItem Value="@(status)"/>
                            }
                        </MudSelect>
                    </MudPaper>
                </MudItem>

                @if (UserAccessService.HasRight(RightEnum.SupportfileActions))
                {
                    <MudItem xs="4">
                        <MudPaper Class="pa-4">
                            <MudToolBar>
                                @if (!_model.Deleted && UserAccessService.HasAnyRights([RightEnum.SupportfileEditTitle, RightEnum.SupportfileEditDescription, RightEnum.SupportfileEditStatus, RightEnum.SupportfileEditMinRank]))
                                {
                                    <MudTooltip Text="Änderungen speichern" Duration="@Constants.TOOLTIP_DURATION">
                                        <MudIconButton Variant="Variant.Text" Color="Color.Primary" Icon="@Icons.Material.Filled.Save" OnClick="() => SaveChanges()"/>
                                    </MudTooltip>
                                }
                            
                                <MudSpacer />

                                @if (_model.Deleted && UserAccessService.HasRight(RightEnum.SupportfileRestore))
                                {
                                    <MudTooltip Text="Supportakte wiederherstellen" Duration="@Constants.TOOLTIP_DURATION">
                                        <MudIconButton Variant="Variant.Text" Color="Color.Success" Icon="@Icons.Material.Filled.RestoreFromTrash" OnClick="() => ToggleFileDeleted()"/>
                                    </MudTooltip>
                                }
                                else if (!_model.Deleted && UserAccessService.HasRight(RightEnum.SupportfileDelete))
                                {
                                    <MudTooltip Text="Supportakte löschen" Duration="@Constants.TOOLTIP_DURATION">
                                        <MudIconButton Variant="Variant.Text" Color="Color.Error" Icon="@Icons.Material.Filled.DeleteForever" OnClick="() => ToggleFileDeleted()"/>
                                    </MudTooltip>
                                }
                            </MudToolBar>
                        </MudPaper>
                    </MudItem>
                }
            </MudGrid>
        </MudTabPanel>
        
        <MudTabPanel Text="Charakterverweise" Icon="@Icons.Material.Filled.AccountCircle" OnClick="() => OpenCharTab()">
            @if (_charApiLoading)
            {
                <LoadingComponent/>
            }
            else
            {
                <MudTextField
                    T="string" @bind-Value="_charSearchString" Placeholder="@Constants.DATAGRID_SEARCHBAR_PLACEHOLDER"
                    Adornment="Adornment.Start" Immediate="true"
                    AdornmentIcon="@Icons.Material.Filled.Search"
                    TextChanged="text => CharSearchTriggered(text)"
                    IconSize="Size.Medium" Class="mt-0"
                    Disabled="@(_model.Deleted ? false : _isLocked)"/>

                <MudPaper Square="true">
                    <MudDropContainer
                        T="CharEntry"
                        ItemDisabled="@(item => !_apiAvailable || _charEntrysUpdating || _isLocked || _model.Deleted)"
                        Items="_filteredCharEntrys"
                        ItemsSelector="@((item, dropzone) => item.DropZoneIdentifier == dropzone)"
                        ItemDropped="CharEntryItemUpdated"
                        Class="d-flex flex-wrap">

                        <ChildContent>
                            <MudPaper Class="ma-4" Width="45%" style="height: 65vh; overflow-y: auto;">
                                <MudList T="string" Class="mud-height-full">
                                    <MudDropZone T="CharEntry" Identifier="available" Class="mud-height-full">
                                        <MudListSubheader>Verfügbar</MudListSubheader>
                                    </MudDropZone>
                                </MudList>
                            </MudPaper>
                            <MudPaper Class="ma-4" Width="45%" style="height: 65vh; overflow-y: auto;">
                                <MudList T="string" Class="mud-height-full">
                                    <MudDropZone T="CharEntry" Identifier="added" Class="mud-height-full">
                                        <MudListSubheader>Hinzugefügt</MudListSubheader>
                                    </MudDropZone>
                                </MudList>
                            </MudPaper>
                        </ChildContent>
                        <ItemRenderer>
                            <MudListItem
                                T="string"
                                Disabled="@(!_apiAvailable || _charEntrysUpdating || _isLocked)">
                                @context.SupportfileCharacterEntryDbModel.GetFullDisplayString()
                            </MudListItem>
                        </ItemRenderer>
                    </MudDropContainer>
                </MudPaper>
            }
        </MudTabPanel>
        
        @if (UserAccessService.HasRight(RightEnum.ViewSupportfileEntrys))
        {
            <MudTabPanel Text="Einträge" Icon="@Icons.Custom.FileFormats.FileDocument" OnClick="() => UnlockCharTab()">
                @if (!_model.Deleted && UserAccessService.HasRight(RightEnum.SupportfileCreateEntrys))
                {
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="ml-auto" OnClick="() => OnClickCreate()">Eintrag hinzufügen</MudButton>
                }
                @if (UserAccessService.HasRight(RightEnum.ViewSupportfileDeletedEntrys))
                {
                    @if (_showDeletedEntrys)
                    {
                        <MudTooltip Text="Gelöschte Einträge ausblenden" Duration="@Constants.TOOLTIP_DURATION">
                            <MudIconButton Color="Color.Secondary" Icon="@Icons.Material.Filled.Delete" OnClick="() => ToggleShowDeletedEntrys()"/>
                        </MudTooltip>
                    }
                    else
                    {
                        <MudTooltip Text="Gelöschte Einträge anzeigen" Duration="@Constants.TOOLTIP_DURATION">
                            <MudIconButton Color="Color.Secondary" Icon="@Icons.Material.Outlined.Delete" OnClick="() => ToggleShowDeletedEntrys()"/>
                        </MudTooltip>
                    }
                }

                <MudPaper Square="true" style="height: 65vh; overflow-y: auto;">
                    <MudList T="object">
                        @foreach (var entry in _entrys)
                        {
                            if (entry != _entrys.First())
                            {
                                <MudDivider/>
                            }

                            <MudCard>
                                <MudCardHeader>
                                    <CardHeaderContent>
                                        <MudText Typo="Typo.h5">@entry.CreatorAccessModel.Name am @entry.CreatedAtLocal(UserAccessService.GetUserAccess().Result.Settings.TimeZone)</MudText>
                                    </CardHeaderContent>
                                </MudCardHeader>
                                <MudCardContent>
                                    <MudTextField @bind-Value="entry.Content" ReadOnly Variant="Variant.Text" Lines="@_entryLines" AutoGrow MaxLines="10"/>
                                    
                                    @if (UserAccessService.HasRight(RightEnum.ViewUploadedFilesForEntrys) && entry.FileUploads.Any())
                                    {
                                        <MudTable Items="entry.FileUploads">
                                            <HeaderContent>
                                                <MudTh>Filename</MudTh>
                                                <MudTh Style="width: 350px;">Size</MudTh>
                                                <MudTh Style="width: 350px;">Upload Date</MudTh>
                                                <MudTh Style="width: 200px;">Actions</MudTh>
                                            </HeaderContent>
                                            <RowTemplate>
                                                <MudTd>@context.FileName</MudTd>
                                                <MudTd>@context.SizeText</MudTd>
                                                <MudTd>@context.UploadDateLocal(UserAccessService.GetUserAccess().Result.Settings.TimeZone)</MudTd>
                                                <MudTd>
                                                    <MudButtonGroup Color="Color.Primary" Variant="Variant.Text">
                                                        @if (UserAccessService.HasRight(RightEnum.SupportfilePreviewFileForEntry))
                                                        {
                                                            <MudTooltip Text="Datei anschauen" Duration="Constants.TOOLTIP_DURATION">
                                                                <MudIconButton Icon="@Icons.Material.Filled.Preview" Color="Color.Info" OnClick="() => PreviewFile(context)"/>
                                                            </MudTooltip>
                                                        }
                                                        @if (UserAccessService.HasRight(RightEnum.SupportfileDownloadFileForEntry))
                                                        {
                                                            <MudTooltip Text="Datei herunterladen" Duration="Constants.TOOLTIP_DURATION">
                                                                <MudIconButton Icon="@Icons.Material.Filled.Download" Color="Color.Tertiary" OnClick="() => DownloadFile(context)"/>
                                                            </MudTooltip>
                                                        }
                                                        @if (!_model.Deleted && UserAccessService.HasRight(RightEnum.SupportfileRenameFileForEntry))
                                                        {
                                                            <MudTooltip Text="Dateinamen ändern" Duration="Constants.TOOLTIP_DURATION">
                                                                <MudIconButton Icon="@Icons.Material.Filled.Edit" Color="Color.Primary" OnClick="() => RenameFile(context)"/>
                                                            </MudTooltip>
                                                        }
                                                        @if (!_model.Deleted && UserAccessService.HasRight(RightEnum.SupportfileDeleteFileForEntry))
                                                        {
                                                            <MudTooltip Text="Datei löschen" Duration="Constants.TOOLTIP_DURATION">
                                                                <MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Secondary" OnClick="() => DeleteFile(context)"/>
                                                            </MudTooltip>
                                                        }
                                                    </MudButtonGroup>
                                                </MudTd>
                                            </RowTemplate>
                                        </MudTable>
                                    }
                                </MudCardContent>
                                <MudCardActions>
                                    <div class="d-flex align-center justify-space-between" style="width: 100%;">
                                        <MudText Style="opacity: 0.2" Typo="Typo.body2">@GetSublineText(entry)</MudText>
                                        <MudButtonGroup Color="Color.Primary" Variant="Variant.Text">
                                            @if (!_model.Deleted && UserAccessService.HasRight(RightEnum.SupportfileUploadFileForEntry))
                                            {
                                                <MudFileUpload T="IBrowserFile" FilesChanged="(file) => UploadFiles(file, entry)" Accept="application/pdf, image/png, image/jpg, image/jpeg">
                                                    <ActivatorContent>
                                                        <MudTooltip Text="Datei hochladen" Duration="Constants.TOOLTIP_DURATION">
                                                            <MudIconButton Icon="@Icons.Material.Filled.CloudUpload" Color="Color.Tertiary"/>
                                                        </MudTooltip>
                                                    </ActivatorContent>
                                                </MudFileUpload>
                                            }
                                            @if (!_model.Deleted && UserAccessService.HasRight(RightEnum.SupportfileEditEntrys))
                                            {
                                                <MudTooltip Text="Eintrag bearbeiten" Duration="Constants.TOOLTIP_DURATION">
                                                    <MudIconButton Variant="Variant.Text" Color="Color.Primary" Icon="@Icons.Material.Filled.Edit" OnClick="() => EditEntry(entry)"/>
                                                </MudTooltip>
                                            }
                                            @if (!_model.Deleted && !entry.Deleted && UserAccessService.HasRight(RightEnum.SupportfileDeleteEntrys))
                                            {
                                                <MudTooltip Text="Eintrag löschen" Duration="Constants.TOOLTIP_DURATION">
                                                    <MudIconButton Variant="Variant.Text" Color="Color.Error" Icon="@Icons.Material.Filled.DeleteForever" OnClick="() => RemoveEntry(entry)"/>
                                                </MudTooltip>
                                            }
                                            else if (!_model.Deleted && entry.Deleted && UserAccessService.HasRight(RightEnum.SupportfileRestoreEntrys))
                                            {
                                                <MudTooltip Text="Eintrag wiederherstellen" Duration="Constants.TOOLTIP_DURATION">
                                                    <MudIconButton Variant="Variant.Text" Color="Color.Success" Icon="@Icons.Material.Filled.RestoreFromTrash" OnClick="() => RestoreEntry(entry)"/>
                                                </MudTooltip>
                                            }
                                        </MudButtonGroup>
                                    </div>
                                </MudCardActions>
                            </MudCard>
                        }
                    </MudList>
                </MudPaper>
            </MudTabPanel>
        }
        
        @if (UserAccessService.HasRight(RightEnum.SupportfileViewLogs))
        {
            <MudTabPanel Text="Logs" Icon="@Icons.Material.Filled.ScreenSearchDesktop" OnClick="() => UnlockCharTab()">
                <MudDataGrid
                    T="SupportfileLogsDbModel" MultiSelection="true"
                    Items="@_logs" SortMode="SortMode.Multiple" Filterable="true"
                    QuickFilter="@QuickFilter"
                    Hideable="true" Hover="true" Striped="true" FixedHeader="true" Height="55vh">
                    <ToolBarContent>
                        <MudText Typo="Typo.h6">Logs für @_model.Id</MudText>
                        <MudSpacer />
                        <MudTextField
                            T="string" @bind-Value="_logSearchString" Placeholder="@Constants.DATAGRID_SEARCHBAR_PLACEHOLDER"
                            Adornment="Adornment.Start" Immediate="true"
                            AdornmentIcon="@Icons.Material.Filled.Search"
                            IconSize="Size.Medium" Class="mt-0"/>
                    </ToolBarContent>
                    <Columns>
                        <PropertyColumn Hideable="false" Property="x => x.Id" Title="#" Filterable="false" />
                        <PropertyColumn Hideable="false" Property="x => x.Content" Title="Information" />
                        <PropertyColumn Hideable="false" Property="x => x.AccessModel.Name" Title="Ersteller" />
                        <PropertyColumn Hideable="false" Property="x => x.AccessId" Title="ErstellerId" />
                        <PropertyColumn Hideable="false" Property="x => x.Type" Title="Type" />
                        <TemplateColumn Hideable="false" Sortable="true" Filterable="true" Title="Datum">
                            <CellTemplate>
                                @context.Item.CreatedAtLocal(UserAccessService.GetUserAccess().Result.Settings.TimeZone)
                            </CellTemplate>
                        </TemplateColumn>
                    </Columns>
                    <PagerContent>
                        <MudDataGridPager T="SupportfileLogsDbModel" />
                    </PagerContent>
                </MudDataGrid>
            </MudTabPanel>
        }
    </MudTabs>
    
    <FileUploadPreview @ref="_fileUploadPreview" Model="_model" HubConnection="_hubConnection" />
}
else
{
    <ErrorComponent/>
}

@code {
    [CascadingParameter] public UserAccessService UserAccessService { get; set; }
    [Parameter] public string Id { get; set; }
    private HubConnection? _hubConnection;
    private bool _loading = true;
    
    private bool _isAuthorized;
    private bool _shouldRedirect;
    private bool _hasNeededRank;

    private SupportfileDbModel? _model;
    private SupportfileDbModel? _checkModel;
    private List<SupportfileLogsDbModel> _logs = [];
    private List<SupportfileEntryDbModel> _entrys = [];
    private List<CharEntry> _charEntrys = [];
    private List<CharEntry> _filteredCharEntrys = [];
    private bool _apiAvailable = false;
    private bool _charEntrysUpdating = false;
    private string? _charSearchString;
    private bool _isLocked;
    private Ulid _lockedByUser;
    private bool _isCurrentTabCharEntrys = false;
    private bool _charApiLoading = true;
    
    private class CharEntry(SupportfileCharacterEntryDbModel supportfileCharacterEntryDbModel, bool isAdded, string dropZoneIdentifier)
    {
        public SupportfileCharacterEntryDbModel SupportfileCharacterEntryDbModel { get; } = supportfileCharacterEntryDbModel;
        public bool IsAdded { get; set; } = isAdded;
        public string DropZoneIdentifier { get; set; } = dropZoneIdentifier;
    }
    
    private static string _dividerStyle = "margin: 10px 0; opacity: 0;";
    private string GetSupportfileTitle() => _checkModel != null ? "Supportakte " + _checkModel.Title : "Loading...";

    private const int _entryLines = 3;
    private bool _showDeletedEntrys = false;
    
    private string? _logSearchString;
    
    private FileUploadPreview? _fileUploadPreview;

    private void CharSearchTriggered(string text)
    {
        if (string.IsNullOrEmpty(text))
        {
            _filteredCharEntrys = _charEntrys;
            return;
        }
        
        _filteredCharEntrys = _charEntrys.Where(x => x.SupportfileCharacterEntryDbModel.GetFullDisplayString().Contains(text)).ToList();
    }
    
    private async Task CharEntryItemUpdated(MudItemDropInfo<CharEntry> dropItem)
    {
        if (dropItem.Item is null) return;
        if (dropItem.Item.DropZoneIdentifier == dropItem.DropzoneIdentifier) return;
        if (_hubConnection is null) return;
        if (_model is null) return;
        if (_model.Deleted) return;
        
        var access = await UserAccessService.GetUserAccess();
        
        dropItem.Item.DropZoneIdentifier = dropItem.DropzoneIdentifier;
        dropItem.Item.IsAdded = !dropItem.Item.IsAdded;
        
        _charEntrysUpdating = true;
        StateHasChanged();
        
        if (dropItem.Item.IsAdded)
        {
            var isAdded = await SupportfileProxy.AddCharEntryAsync(dropItem.Item.SupportfileCharacterEntryDbModel, access.Id);
            if (!isAdded)
            {
                Snackbar.Add($"{dropItem.Item.SupportfileCharacterEntryDbModel.GetFullDisplayString()} konnte nicht hinzugefügt werden.", Severity.Error);
            }
            else
            {
                Snackbar.Add($"{dropItem.Item.SupportfileCharacterEntryDbModel.GetFullDisplayString()} zu Supportakte hinzugefügt.", Severity.Success);
                await _hubConnection.SendAsync(SupportfileHubMethodEnum.UpdateFile.ToString(), _model.Id);
            }
        }
        else
        {
            var isRemoved = await SupportfileProxy.RemoveCharEntryAsync(dropItem.Item.SupportfileCharacterEntryDbModel, access.Id);
            if (!isRemoved)
            {
                Snackbar.Add($"{dropItem.Item.SupportfileCharacterEntryDbModel.GetFullDisplayString()} konnte nicht entfernt werden.", Severity.Error);
            }
            else
            {
                Snackbar.Add($"{dropItem.Item.SupportfileCharacterEntryDbModel.GetFullDisplayString()} von Supportakte entfernt.", Severity.Success);
                await _hubConnection.SendAsync(SupportfileHubMethodEnum.UpdateFile.ToString(), _model.Id);
            }
        }
        
        _charEntrysUpdating = false;
        StateHasChanged();
    }
    
    private async Task UploadFiles(IBrowserFile? file, SupportfileEntryDbModel entryDbModel)
    {
        if (_model is null) return;
        if (_model.Deleted) return;
        if (_hubConnection is null) return;
        if (_fileUploadPreview is null) return;
        if (file is null) return;

        var maxFileSize = SupportfileEntryProxy.GetMaxFileSize();
        if (file.Size > maxFileSize)
        {
            Snackbar.Add("Datei ist zu groß!", Severity.Error);
            return;
        }
        
        try
        {
            var fileDbModel = await GetFileUploadDbModel(file, entryDbModel);
            if (fileDbModel is null)
            {
                Snackbar.Add($"Dateiformat [{file.ContentType}] wird nicht unterstützt.", Severity.Error);
                return;
            }
            
            _fileUploadPreview.OpenFile(fileDbModel, true);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Fehler beim Hochladen der Datei: {ex.Message}", Severity.Error);
        }
    }

    private async Task<SupportfileFileUploadDbModel?> GetFileUploadDbModel(IBrowserFile file, SupportfileEntryDbModel entryDbModel)
    {
        var maxFileSize = SupportfileEntryProxy.GetMaxFileSize();
        
        // should outsource the contentType in a enum, but i'm to lazy rn
        switch (file.ContentType)
        {
            case "image/png":
            case "image/jpeg":
            case "image/jpg":
            {
                var resizedFile = await file.RequestImageFileAsync(file.ContentType, 800, 600);
                using var stream = resizedFile.OpenReadStream(maxFileSize);

                using var memoryStream = new MemoryStream();
                await stream.CopyToAsync(memoryStream);
                var buffer = memoryStream.ToArray(); 
        
                return new SupportfileFileUploadDbModel(entryDbModel.Id, file.Name, file.ContentType, buffer);
            }
            case "application/pdf":
            {
                using var stream = file.OpenReadStream(maxFileSize);
                using var memoryStream = new MemoryStream();
                await stream.CopyToAsync(memoryStream);
                var buffer = memoryStream.ToArray();
                
                return new SupportfileFileUploadDbModel(entryDbModel.Id, file.Name, file.ContentType, buffer);
            }
            default:
                return null;
        }
    }

    private async Task DeleteFile(SupportfileFileUploadDbModel file)
    {
        if (_model is null) return;
        if (_model.Deleted) return;
        if (_fileUploadPreview is null) return;
        await _fileUploadPreview.DeleteFile(file);
    }
    
    private async Task DownloadFile(SupportfileFileUploadDbModel file)
    {
        if (_fileUploadPreview is null) return;
        await _fileUploadPreview.DownloadFile(file);
    }

    private async Task RenameFile(SupportfileFileUploadDbModel file)
    {
        if (_model is null) return;
        if (_model.Deleted) return;
        if (_fileUploadPreview is null) return;
        await _fileUploadPreview.RenameFile(file);
    }

    private void PreviewFile(SupportfileFileUploadDbModel file)
    {
        _fileUploadPreview?.OpenFile(file, false);
    }
    
    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        _isAuthorized = UserAccessService.HasRight(PageRightRegistry.GetNeededRankForPage(Url));
        _shouldRedirect = !_isAuthorized;
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;

        if (_shouldRedirect)
        {
            Navigation.NavigateToNotAuthorized();
            return;
        }
            
        await StartHubConnection();
        await Load();
    }

    private async Task Load()
    {
        await LoadModel();

        await LoadCharEntrys();
    }
    
    private async Task LoadModel()
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        
        if (!Ulid.TryParse(Id, out var fileId))
        {
            Snackbar.Add("Parsing failed", Severity.Error);
            _loading = false;
            return;
        }
        
        var model = await SupportfileProxy.GetFullAsync(fileId);
        if (model is null)
        {
            Snackbar.Add("Ein Fehler beim Laden ist aufgetreten.", Severity.Error);
            _loading = false;
            return;
        }

        if (access.Rank < model.MinRank)
        {
            Navigation.NavigateToNotAuthorized();
            return;
        }

        _hasNeededRank = true;

        _model = model;
        _checkModel = _model.CreateShallowCopy();
        
        @if (UserAccessService.HasRight(RightEnum.ViewSupportfileEntrys))
        {
            _entrys = _showDeletedEntrys ?
                _model.Entrys
                    .OrderByDescending(x => x.Id)
                    .ToList() :
                _model.Entrys
                    .Where(x => !x.Deleted)
                    .OrderByDescending(x => x.Id)
                    .ToList();
        }
        
        @if (UserAccessService.HasRight(RightEnum.SupportfileViewLogs))
        {
            _logs = _model.Logs
                .OrderByDescending(x => x.Id)
                .ToList();;
        }
        
        _loading = false;
        StateHasChanged();
    }

    private async Task LoadCharEntrys()
    {
        if (_model is null) return;
        _charApiLoading = true;

        _charEntrys = _model.CharacterEntrys.Select(x => new CharEntry(x, true, "added")).ToList();
        var addedCharIds = _model.CharacterEntrys.Select(x => x.CharacterId);

        try
        {
            var response = await CharacterApi.GetAllAsync();
            if (response.IsSuccessStatusCode)
            {
                var allChars = response.Content;

                foreach (var characterApiModel in allChars.Where(x => !addedCharIds.Contains(x.Id)))
                {
                    var charEntry = new SupportfileCharacterEntryDbModel(_model.Id, characterApiModel.AccountId, characterApiModel.Id, characterApiModel.FirstName, characterApiModel.LastName);

                    _charEntrys.Add(new CharEntry(charEntry, false, "available"));
                }

                _apiAvailable = true;
            }
            else
            {
                Snackbar.Add(response.Error.Message, Severity.Error);
                _apiAvailable = false;
            }
        }
        catch (HttpRequestException ex)
        {
            Snackbar.Add(Constants.API_ERROR_NOT_AVAILABLE, Severity.Error);
            _apiAvailable = false;
        }
        catch (Exception ex)
        {
            Snackbar.Add(ex.Message, Severity.Error);
            _apiAvailable = false;
        }

        _charApiLoading = false;
        _filteredCharEntrys = _charEntrys;
        StateHasChanged();
    }

    private async Task OnClickCreate()
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        if (_model is null) return;
        if (_model.Deleted) return;
        if (!UserAccessService.HasRight(RightEnum.SupportfileCreateEntrys)) return;
        
        var inputs = new List<InputModel>
        {
            new(
                InputTypes.Text,
                "Nachricht/Information",
                string.Empty,
                "Am... Mit... Beschlossen...",
                _entryLines
            ),
        };

        var dialogData = await DialogService.OpenDialog(
            "Eintrag hinzufügen", 
            "Welche Information möchtest du hinzufügen?", 
            "Eintrag hinzufügen",
            inputs);
        if (dialogData is null) return;
        
        var (validated, message) = dialogData[0].ValidateInput<string>();
        if (!validated)
        {
            Snackbar.Add("Es wurde keine Nachricht eingetragen!", Severity.Error);
            return;
        }

        var response = await SupportfileEntryProxy.AddEntryAsync(new SupportfileEntryDbModel(_model.Id, message!, access.Id));
        if (response is null)
        {
            Snackbar.Add("Nachricht konnte nicht hinzugefügt werden!", Severity.Error);
            return;
        }

        await SendUpdateEntryToHub();
    }

    private async Task StartHubConnection()
    {
        _hubConnection = HubHelper.GetHubConnection(Navigation, SupportfileHub.HubPattern);
        
        _hubConnection.On<Ulid>(SupportfileHubMethodEnum.UpdateFile.ToString(), async (id) =>
        {
            if (_model is null) return;
            if (id != _model.Id) return;
            
            await InvokeAsync(Load);
            StateHasChanged();
        });
        
        _hubConnection.On<Ulid>(SupportfileHubMethodEnum.UpdateEntrys.ToString(), async (id) =>
        {
            if (_model is null) return;
            if (id != _model.Id) return;
            
            await InvokeAsync(Load);
            StateHasChanged();
        });
        
        _hubConnection.On<Ulid>(SupportfileHubMethodEnum.ToggleFileDeleted.ToString(), async (id) =>
        {
            if (_model is null) return;
            if (id != _model.Id) return;

            if (!_model.Deleted)
            {
                Navigation.NavigateTo(SupportfileOverview.GetRedirectUrl());
                return;
            }

            await InvokeAsync(Load);
            StateHasChanged();
        });
        
        _hubConnection.On<Ulid, Ulid>("FileLocked", (fileId, userId) =>
        {
            if (_model is null) return;
            if (fileId != _model.Id) return;
            
            _isLocked = true;
            _lockedByUser = userId;
            InvokeAsync(StateHasChanged);
        });

        
        _hubConnection.On<Ulid, Ulid>("FileUnlocked", (fileId, userId) =>
        {
            if (_model is null) return;
            if (fileId != _model.Id) return;

            _isLocked = false;
            _lockedByUser = Ulid.Empty;
            InvokeAsync(StateHasChanged);

            if (!_isCurrentTabCharEntrys) return;

            InvokeAsync(LockCharTabAsync);
        });
        
        await _hubConnection.StartAsync();
        
        if (_model is null) return;
        
        _isLocked = await GetLockCharTabAsync();
        if (_isLocked)
        {
            _lockedByUser = await _hubConnection.InvokeAsync<Ulid>("GetLockedByUser", _model.Id);
        }
    }

    private async Task OpenCharTab()
    {
        if (_isCurrentTabCharEntrys) return;
        _isCurrentTabCharEntrys = true;
        if (_model is null) return;
        if (_hubConnection is null) return;

        _isLocked = await GetLockCharTabAsync();
        if (_isLocked)
        {
            _lockedByUser = await _hubConnection.InvokeAsync<Ulid>("GetLockedByUser", _model.Id);
            return;
        }

        await LockCharTabAsync();
    }

    private async Task<bool> GetLockCharTabAsync()
    {
        if (_model is null) return false;
        if (_hubConnection is null) return false;
        
        return await _hubConnection.InvokeAsync<bool>("IsFileLocked", _model.Id);
    }
    
    private async Task LockCharTabAsync()
    {
        if (_model is null) return;
        if (_hubConnection is null) return;
        
        var access = await UserAccessService.GetUserAccess();
        
        await _hubConnection.InvokeAsync("LockFile", _model.Id, access.Id);
        _lockedByUser = access.Id;
    }

    private async Task UnlockCharTab()
    {
        _isCurrentTabCharEntrys = false;
        if (_isLocked) return;
        
        if (_model is null) return;
        if (_hubConnection is null) return;
        
        var access = await UserAccessService.GetUserAccess();

        if (_lockedByUser != access.Id) return;
        
        await _hubConnection.InvokeAsync("UnlockFile", _model.Id, access.Id);
        _lockedByUser = Ulid.Empty;
    }
    
    private async Task SendUpdateEntryToHub()
    {
        if (_model is null) return;
        if (_hubConnection is null) return;
        
        await _hubConnection.SendAsync(SupportfileHubMethodEnum.UpdateEntrys.ToString(), _model.Id);
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is null) return;
 
        await UnlockCharTab();
        await _hubConnection.DisposeAsync();
    }
    
    private async Task EditEntry(SupportfileEntryDbModel entry)
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        if (_model is null) return;
        if (_model.Deleted) return;
        if (!UserAccessService.HasRight(RightEnum.SupportfileEditEntrys)) return;
        
        const string title = "Eintrag bearbeiten";
        var description = "Wie möchtest du den Eintrag bearbeiten?";
        const string submitButtonText = "Eintrag bearbeitet";

        const string messageLabel = "Nachricht/Information";

        var inputs = new List<InputModel>
        {
            new(
                InputTypes.Text,
                messageLabel,
                entry.Content,
                "Am... Mit... Beschlossen...",
                _entryLines
            ),
        };

        var parameter = new DialogParameters<SimpleMudDialog>
        {
            { x => x.Description, description },
            { x => x.Inputs, inputs },
            { x => x.SubmitButtonText, submitButtonText },
        };

        var dialog = await DialogService.ShowAsync<SimpleMudDialog>(title, parameter, new DialogOptions { FullWidth = true });
        var dialogResult = await dialog.Result;

        if (dialogResult != null && dialogResult.Canceled) return;

        var data = (List<InputModel>)dialogResult.Data!;
        var message = data.First(x => x.Label == messageLabel).Value;

        if (string.IsNullOrEmpty(message))
        {
            Snackbar.Add("Es wurde keine Nachricht eingetragen!", Severity.Error);
            return;
        }

        var response = await SupportfileEntryProxy.UpdateEntryContentAsync(entry.Id, message, access.Id);
        if (!response)
        {
            Snackbar.Add("Nachricht konnte nicht bearbeitet werden!", Severity.Error);
            return;
        }

        await SendUpdateEntryToHub();
    }

    private async Task RemoveEntry(SupportfileEntryDbModel entry)
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        if (_model is null) return;
        if (_model.Deleted) return;
        if (!UserAccessService.HasRight(RightEnum.SupportfileDeleteEntrys)) return;
        
        var result = await DialogService.ShowMessageBox(
            "Eintrag löschen", 
            "Bist du dir sicher diesen Eintrag zu löschen? Dies kann nicht mehr rückgängig gemacht werden!", 
            yesText:"Löschen!", cancelText:"Abbrechen"
        );

        if (result is null or false) return;

        var response = await SupportfileEntryProxy.RemoveEntryAsync(entry.Id, access.Id);
        if (!response)
        {
            Snackbar.Add("Dieser Eintrag konnte nicht gelöscht werden!");
            return;
        }
        
        await SendUpdateEntryToHub();
    }

    private async Task RestoreEntry(SupportfileEntryDbModel entry)
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        if (_model is null) return;
        if (_model.Deleted) return;
        if (!UserAccessService.HasRight(RightEnum.SupportfileDeleteEntrys)) return;
        
        var result = await DialogService.ShowMessageBox(
            "Eintrag wiederherstellen", 
            "Bist du dir sicher diesen Eintrag zu wiederherzustellen?", 
            yesText:"Wiederherstellen!", cancelText:"Abbrechen"
        );

        if (result is null or false) return;

        var response = await SupportfileEntryProxy.RestoreEntryAsync(entry.Id, access.Id);
        if (!response)
        {
            Snackbar.Add("Dieser Eintrag konnte nicht gelöscht werden!");
            return;
        }
        
        await SendUpdateEntryToHub();
    }


    private string GetSublineText(SupportfileEntryDbModel entry)
    {
        return $"{entry.Id}" + (entry.CreatedAtLocal() != entry.ModifiedAtLocal() ? $" - geändert {entry.ModifiedAtLocal(UserAccessService.GetUserAccess().Result.Settings.TimeZone)}" : string.Empty);
    }
    
    private Func<SupportfileLogsDbModel, bool> QuickFilter => x =>
    {
        if (_logSearchString == null) return true;
        
        var lowerSearchString = _logSearchString.ToLower();
        
        if (string.IsNullOrWhiteSpace(lowerSearchString))
            return true;

        if (x.Content.ToLower().Contains(lowerSearchString, StringComparison.OrdinalIgnoreCase))
            return true;

        if (x.Type.ToString().ToLower().Contains(lowerSearchString, StringComparison.OrdinalIgnoreCase))
            return true;
        
        if (x.CreatedAtLocal(UserAccessService.GetUserAccess().Result.Settings.TimeZone).ToLower().Contains(lowerSearchString, StringComparison.OrdinalIgnoreCase))
            return true;
        
        if ($"{x.Id}".ToLower().Contains(lowerSearchString))
            return true;

        return false;
    };

    private async Task ToggleFileDeleted()
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        if (_model is null) return;
        if (_hubConnection is null) return;

        if (_model.Deleted && !UserAccessService.HasRight(RightEnum.SupportfileRestore)) return;
        if (!_model.Deleted && !UserAccessService.HasRight(RightEnum.SupportfileDelete)) return;

        var title = _model.Deleted ? "Supportakte wiederherstellen" : "Supportakte löschen";
        var message = _model.Deleted ? 
            "Bist du dir sicher diese Supportakte wiederherzustellen?" : 
            "Bist du dir sicher diese Supportakte zu löschen? Dies kann nicht mehr rückgängig gemacht werden!";
        var yesText = _model.Deleted ? "Wiederherstellen" : "Löschen";
        
        var result = await DialogService.ShowMessageBox(
            title, 
            message, 
            yesText:yesText, cancelText:"Abbrechen"
        );

        if (result is null or false) return;

        var response = await SupportfileProxy.ToggleDeletedAsync(_model.Id, access.Id);
        if (!response)
        {
            Snackbar.Add("Dieser Supportakte konnte nicht gelöscht/wiederhergestellt werden!");
            return;
        }
        
        await _hubConnection.SendAsync(SupportfileHubMethodEnum.ToggleFileDeleted.ToString(), _model.Id);
    }

    private async Task SaveChanges()
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        if (_model is null) return;
        if (_model.Deleted) return;
        if (_hubConnection is null) return; 
        
        if (_model is null || _checkModel is null || access is null)
        {
            Snackbar.Add("Mögliche Änderungen konnte nicht aktualisiert werden.", Severity.Error);
            return;
        }

        var shouldReload = false;
        
        if (_checkModel.Title != _model.Title && UserAccessService.HasRight(RightEnum.SupportfileEditTitle))
        {
            var updateResponse = await SupportfileProxy.UpdateTitleAsync(_model.Id, _model.Title, access.Id);
            if (!updateResponse)
            {
                Snackbar.Add("Title konnte nicht aktualisiert werden.", Severity.Error);
            }
            else
            {
                Snackbar.Add("Title wurde aktualisiert.", Severity.Success);
                shouldReload = true;
            }
        }
        
        if (_checkModel.Description != _model.Description && UserAccessService.HasRight(RightEnum.SupportfileEditDescription))
        {
            var updateResponse = await SupportfileProxy.UpdateDescriptionAsync(_model.Id, _model.Description, access.Id);
            if (!updateResponse)
            {
                Snackbar.Add("Description konnte nicht aktualisiert werden.", Severity.Error);
            }
            else
            {
                Snackbar.Add("Description wurde aktualisiert.", Severity.Success);
                shouldReload = true;
            }
        }
        
        if (_checkModel.Status != _model.Status && UserAccessService.HasRight(RightEnum.SupportfileEditStatus))
        {
            var updateResponse = await SupportfileProxy.UpdateStatusAsync(_model.Id, _model.Status, access.Id);
            if (!updateResponse)
            {
                Snackbar.Add("Status konnte nicht aktualisiert werden.", Severity.Error);
            }
            else
            {
                Snackbar.Add("Status wurde aktualisiert.", Severity.Success);
                shouldReload = true;
            }
        }
        
        if (_checkModel.MinRank != _model.MinRank && UserAccessService.HasRight(RightEnum.SupportfileEditMinRank))
        {
            var updateResponse = await SupportfileProxy.UpdateMinRankAsync(_model.Id, _model.MinRank, access.Id);
            if (!updateResponse)
            {
                Snackbar.Add("MinRank konnte nicht aktualisiert werden.", Severity.Error);
            }
            else
            {
                Snackbar.Add("MinRank wurde aktualisiert.", Severity.Success);
                shouldReload = true;
            }
        }

        if (!shouldReload) return;
        
        await _hubConnection.SendAsync(SupportfileHubMethodEnum.UpdateFile.ToString(), _model.Id);
    }

    private async Task ToggleShowDeletedEntrys()
    {
        _showDeletedEntrys = !_showDeletedEntrys;

        await Load();
    }
}