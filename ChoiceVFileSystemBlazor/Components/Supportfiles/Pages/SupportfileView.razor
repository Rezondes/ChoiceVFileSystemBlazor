@page "/supportfiles/view/{id}"
@using System.Globalization

@code {
    public const string Url = "/supportfiles/view/";
    public static string GetRedirectUrl(string id) => Url + id;
}

<PageTitle>@(GetSupportfileTitle())</PageTitle>
<h1>@(GetSupportfileTitle())</h1>

@if (_loading || _hubConnection is null || !_isAuthorized || !_hasNeededRank || _model is null)
{
    <PageLoading/>
}
else if (_model is not null)
{
    <MudTabs Elevation="2" Rounded="true" ApplyEffectsToContainer="true" PanelClass="pa-6 height-85" Style="height: 100%">
        <MudTabPanel Text="Allgemein" Icon="@Icons.Material.Filled.Info">
            <MudGrid Justify="Justify.FlexStart">
                <MudItem xs="8">
                    <MudPaper Class="pa-4">
                        <MudTextField Label="Ersteller" Variant="Variant.Outlined" ReadOnly Value="@_model.CreatorAccessModel.Name"/>

                        <MudDivider Style="@_dividerStyle"/>
                        <MudTextField Label="Titel" Variant="Variant.Outlined" ReadOnly="@(!UserAccessService.HasRight(RightEnum.SupportfileEditTitle))" @bind-Value="_model.Title"/>

                        <MudDivider Style="@_dividerStyle"/>
                        <MudTextField Label="Beschreibung" Lines="3" Variant="Variant.Outlined" ReadOnly="@(!UserAccessService.HasRight(RightEnum.SupportfileEditDescription))" @bind-Value="_model.Description"/>

                        <MudDivider Style="@_dividerStyle"/>
                        <MudSelect T="FileStatusEnum" Label="Status" Variant="Variant.Outlined" ReadOnly="@(!UserAccessService.HasRight(RightEnum.SupportfileEditStatus))" @bind-Value="_model.Status">
                            @foreach (FileStatusEnum status in Enum.GetValues(typeof(FileStatusEnum)))
                            {
                                <MudSelectItem Value="@(status)"/>
                            }
                        </MudSelect>

                        <MudDivider Style="@_dividerStyle"/>
                        <MudSelect T="RankEnum" Label="MinRank" Variant="Variant.Outlined" ReadOnly="@(!UserAccessService.HasRight(RightEnum.SupportfileEditMinRank))" @bind-Value="_model.MinRank">
                            @foreach (RankEnum status in Enum.GetValues(typeof(RankEnum)))
                            {
                                <MudSelectItem Value="@(status)"/>
                            }
                        </MudSelect>
                    </MudPaper>
                </MudItem>

                @if (UserAccessService.HasRight(RightEnum.SupportfileActions))
                {
                    <MudItem xs="4">
                        <MudPaper Class="pa-4">
                            <MudToolBar>
                                @if (UserAccessService.HasAnyRights([RightEnum.SupportfileEditTitle, RightEnum.SupportfileEditDescription, RightEnum.SupportfileEditStatus, RightEnum.SupportfileEditMinRank]))
                                {
                                    <MudTooltip Text="Änderungen speichern" Duration="@Constants.TOOLTIP_DURATION">
                                        <MudIconButton Variant="Variant.Text" Color="Color.Primary" Icon="@Icons.Material.Filled.Save" OnClick="() => SaveChanges()"/>
                                    </MudTooltip>
                                }
                            
                                <MudSpacer />

                                @if (_model.Deleted && UserAccessService.HasRight(RightEnum.SupportfileRestore))
                                {
                                    <MudTooltip Text="Supportakte wiederherstellen" Duration="@Constants.TOOLTIP_DURATION">
                                        <MudIconButton Variant="Variant.Text" Color="Color.Success" Icon="@Icons.Material.Filled.RestoreFromTrash" OnClick="() => ToggleFileDeleted()"/>
                                    </MudTooltip>
                                }
                                else if (!_model.Deleted && UserAccessService.HasRight(RightEnum.SupportfileDelete))
                                {
                                    <MudTooltip Text="Supportakte löschen" Duration="@Constants.TOOLTIP_DURATION">
                                        <MudIconButton Variant="Variant.Text" Color="Color.Error" Icon="@Icons.Material.Filled.DeleteForever" OnClick="() => ToggleFileDeleted()"/>
                                    </MudTooltip>
                                }
                            </MudToolBar>
                        </MudPaper>
                    </MudItem>
                }
            </MudGrid>
        </MudTabPanel>
        
        @if (UserAccessService.HasRight(RightEnum.ViewSupportfileEntrys))
        {
            <MudTabPanel Text="Einträge" Icon="@Icons.Custom.FileFormats.FileDocument">
                @if (UserAccessService.HasRight(RightEnum.SupportfileCreateEntrys))
                {
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="ml-auto" OnClick="() => OnClickCreate()">Eintrag hinzufügen</MudButton>
                }
                @if (UserAccessService.HasRight(RightEnum.ViewSupportfileDeletedEntrys))
                {
                    @if (_showDeletedEntrys)
                    {
                        <MudTooltip Text="Gelöschte Einträge ausblenden" Duration="@Constants.TOOLTIP_DURATION">
                            <MudIconButton Color="Color.Secondary" Icon="@Icons.Material.Filled.Delete" OnClick="() => ToggleShowDeletedEntrys()"/>
                        </MudTooltip>
                    }
                    else
                    {
                        <MudTooltip Text="Gelöschte Einträge anzeigen" Duration="@Constants.TOOLTIP_DURATION">
                            <MudIconButton Color="Color.Secondary" Icon="@Icons.Material.Outlined.Delete" OnClick="() => ToggleShowDeletedEntrys()"/>
                        </MudTooltip>
                    }
                }

                <MudPaper Square="true" style="height: 70vh; overflow-y: auto;">
                    <MudList T="object">
                        @foreach (var entry in _entrys)
                        {
                            if (entry != _entrys.First())
                            {
                                <MudDivider/>
                            }

                            <MudCard>
                                <MudCardHeader>
                                    <CardHeaderContent>
                                        <MudText Typo="Typo.h5">@entry.CreatorAccessModel.Name am @entry.CreatedAtLocal()</MudText>
                                    </CardHeaderContent>
                                </MudCardHeader>
                                <MudCardContent>
                                    <MudTextField @bind-Value="entry.Content" ReadOnly Variant="Variant.Text" Lines="@_entryLines" AutoGrow MaxLines="10"/>
                                    
                                    @if (UserAccessService.HasRight(RightEnum.ViewUploadedFilesForEntrys) && entry.FileUploads.Any())
                                    {
                                        <MudTable Items="entry.FileUploads">
                                            <HeaderContent>
                                                <MudTh>Filename</MudTh>
                                                <MudTh Style="width: 350px;">Size</MudTh>
                                                <MudTh Style="width: 350px;">Upload Date</MudTh>
                                                <MudTh Style="width: 200px;">Actions</MudTh>
                                            </HeaderContent>
                                            <RowTemplate>
                                                <MudTd>@context.FileName</MudTd>
                                                <MudTd>@context.SizeText</MudTd>
                                                <MudTd>@context.UploadDateLocal()</MudTd>
                                                <MudTd>
                                                    <MudButtonGroup Color="Color.Primary" Variant="Variant.Text">
                                                        @if (UserAccessService.HasRight(RightEnum.SupportfilePreviewFileForEntry))
                                                        {
                                                            <MudTooltip Text="Datei anschauen" Duration="Constants.TOOLTIP_DURATION">
                                                                <MudIconButton Icon="@Icons.Material.Filled.Preview" Color="Color.Info" OnClick="() => PreviewFile(context)"/>
                                                            </MudTooltip>
                                                        }
                                                        @if (UserAccessService.HasRight(RightEnum.SupportfileDownloadFileForEntry))
                                                        {
                                                            <MudTooltip Text="Datei herunterladen" Duration="Constants.TOOLTIP_DURATION">
                                                                <MudIconButton Icon="@Icons.Material.Filled.Download" Color="Color.Tertiary" OnClick="() => DownloadFile(context)"/>
                                                            </MudTooltip>
                                                        }
                                                        @if (UserAccessService.HasRight(RightEnum.SupportfileRenameFileForEntry))
                                                        {
                                                            <MudTooltip Text="Dateinamen ändern" Duration="Constants.TOOLTIP_DURATION">
                                                                <MudIconButton Icon="@Icons.Material.Filled.Edit" Color="Color.Primary" OnClick="() => RenameFile(context)"/>
                                                            </MudTooltip>
                                                        }
                                                        @if (UserAccessService.HasRight(RightEnum.SupportfileDeleteFileForEntry))
                                                        {
                                                            <MudTooltip Text="Datei löschen" Duration="Constants.TOOLTIP_DURATION">
                                                                <MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Secondary" OnClick="() => DeleteFile(context)"/>
                                                            </MudTooltip>
                                                        }
                                                    </MudButtonGroup>
                                                </MudTd>
                                            </RowTemplate>
                                        </MudTable>
                                    }
                                </MudCardContent>
                                <MudCardActions>
                                    <div class="d-flex align-center justify-space-between" style="width: 100%;">
                                        <MudText Style="opacity: 0.2" Typo="Typo.body2">@GetSublineText(entry)</MudText>
                                        <MudButtonGroup Color="Color.Primary" Variant="Variant.Text">
                                            @if (UserAccessService.HasRight(RightEnum.SupportfileUploadFileForEntry))
                                            {
                                                <MudFileUpload T="IBrowserFile" FilesChanged="(file) => UploadFiles(file, entry)" Accept="application/pdf, image/png, image/jpg, image/jpeg">
                                                    <ActivatorContent>
                                                        <MudTooltip Text="Datei hochladen" Duration="Constants.TOOLTIP_DURATION">
                                                            <MudIconButton Icon="@Icons.Material.Filled.CloudUpload" Color="Color.Tertiary"/>
                                                        </MudTooltip>
                                                    </ActivatorContent>
                                                </MudFileUpload>
                                            }
                                            @if (UserAccessService.HasRight(RightEnum.SupportfileEditEntrys))
                                            {
                                                <MudTooltip Text="Eintrag bearbeiten" Duration="Constants.TOOLTIP_DURATION">
                                                    <MudIconButton Variant="Variant.Text" Color="Color.Primary" Icon="@Icons.Material.Filled.Edit" OnClick="() => EditEntry(entry)"/>
                                                </MudTooltip>
                                            }
                                            @if (!entry.Deleted && UserAccessService.HasRight(RightEnum.SupportfileDeleteEntrys))
                                            {
                                                <MudTooltip Text="Eintrag löschen" Duration="Constants.TOOLTIP_DURATION">
                                                    <MudIconButton Variant="Variant.Text" Color="Color.Error" Icon="@Icons.Material.Filled.DeleteForever" OnClick="() => RemoveEntry(entry)"/>
                                                </MudTooltip>
                                            }
                                            else if (entry.Deleted && UserAccessService.HasRight(RightEnum.SupportfileRestoreEntrys))
                                            {
                                                <MudTooltip Text="Eintrag wiederherstellen" Duration="Constants.TOOLTIP_DURATION">
                                                    <MudIconButton Variant="Variant.Text" Color="Color.Success" Icon="@Icons.Material.Filled.RestoreFromTrash" OnClick="() => RestoreEntry(entry)"/>
                                                </MudTooltip>
                                            }
                                        </MudButtonGroup>
                                    </div>
                                </MudCardActions>
                            </MudCard>
                        }
                    </MudList>
                </MudPaper>
            </MudTabPanel>
        }
        
        @if (UserAccessService.HasRight(RightEnum.SupportfileViewLogs))
        {
            <MudTabPanel Text="Logs" Icon="@Icons.Material.Filled.ScreenSearchDesktop">
                <MudDataGrid
                    T="SupportfileLogsDbModel" MultiSelection="true"
                    Items="@_logs" SortMode="SortMode.Multiple" Filterable="true"
                    QuickFilter="@QuickFilter"
                    Hideable="true" Hover="true" Striped="true" FixedHeader="true" Height="65vh">
                    <ToolBarContent>
                        <MudText Typo="Typo.h6">Logs für @_model.Id</MudText>
                        <MudSpacer />
                        <MudTextField
                            T="string" @bind-Value="_logSearchString" Placeholder="@Constants.DATAGRID_SEARCHBAR_PLACEHOLDER"
                            Adornment="Adornment.Start" Immediate="true"
                            AdornmentIcon="@Icons.Material.Filled.Search"
                            IconSize="Size.Medium" Class="mt-0"/>
                    </ToolBarContent>
                    <Columns>
                        <PropertyColumn Hideable="false" Property="x => x.Id" Title="#" Filterable="false" />
                        <PropertyColumn Hideable="false" Property="x => x.Content" Title="Information" />
                        <PropertyColumn Hideable="false" Property="x => x.AccessModel.Name" Title="Ersteller" />
                        <PropertyColumn Hideable="false" Property="x => x.AccessId" Title="ErstellerId" />
                        <PropertyColumn Hideable="false" Property="x => x.Type" Title="Type" />
                        <TemplateColumn Hideable="false" Sortable="true" Filterable="true" Title="Datum">
                            <CellTemplate>
                                @context.Item.CreatedAtLocal()
                            </CellTemplate>
                        </TemplateColumn>
                    </Columns>
                    <PagerContent>
                        <MudDataGridPager T="SupportfileLogsDbModel" />
                    </PagerContent>
                </MudDataGrid>
            </MudTabPanel>
        }
    </MudTabs>
    
    <FileUploadPreview @ref="_fileUploadPreview" Model="_model" HubConnection="_hubConnection" />
}
else
{
    <MudAlert Severity="Severity.Error">Ein Fehler ist aufgetreten!</MudAlert>
}

@code {
    [CascadingParameter] public UserAccessService UserAccessService { get; set; }
    [Parameter] public string Id { get; set; }
    private HubConnection? _hubConnection;
    private bool _loading = true;
    
    private bool _isAuthorized;
    private bool _shouldRedirect;
    private bool _hasNeededRank;

    private SupportfileDbModel? _model;
    private SupportfileDbModel? _checkModel;
    private List<SupportfileLogsDbModel> _logs = [];
    private List<SupportfileEntryDbModel> _entrys = [];
    private List<AccessDbModel> _allAccessModels = [];
    
    private static string _dividerStyle = "margin: 10px 0; opacity: 0;";
    private string GetSupportfileTitle() => _model != null ? "Supportakte " + _model.Title : "Loading...";

    private const int _entryLines = 3;
    private bool _showDeletedEntrys = false;
    
    private string? _logSearchString;
    
    private FileUploadPreview? _fileUploadPreview;
    
    private async Task UploadFiles(IBrowserFile? file, SupportfileEntryDbModel entryDbModel)
    {
        if (_model is null) return;
        if (_hubConnection is null) return;
        if (_fileUploadPreview is null) return;
        if (file is null) return;

        var maxFileSize = SupportfileEntryProxy.GetMaxFileSize();
        if (file.Size > maxFileSize)
        {
            Snackbar.Add("Datei ist zu groß!", Severity.Error);
            return;
        }
        
        try
        {
            var fileDbModel = await GetFileUploadDbModel(file, entryDbModel);
            if (fileDbModel is null)
            {
                Snackbar.Add($"Dateiformat [{file.ContentType}] wird nicht unterstützt.", Severity.Error);
                return;
            }
            
            _fileUploadPreview.OpenFile(fileDbModel, true);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Fehler beim Hochladen der Datei: {ex.Message}", Severity.Error);
        }
    }

    private async Task<SupportfileFileUploadDbModel?> GetFileUploadDbModel(IBrowserFile file, SupportfileEntryDbModel entryDbModel)
    {
        var maxFileSize = SupportfileEntryProxy.GetMaxFileSize();
        
        switch (file.ContentType)
        {
            case "image/png":
            case "image/jpeg":
            case "image/jpg":
            {
                var resizedFile = await file.RequestImageFileAsync(file.ContentType, 800, 600);
                using var stream = resizedFile.OpenReadStream(maxFileSize);

                using var memoryStream = new MemoryStream();
                await stream.CopyToAsync(memoryStream);
                var buffer = memoryStream.ToArray(); 
        
                return new SupportfileFileUploadDbModel(entryDbModel.Id, file.Name, file.ContentType, buffer);
            }
            case "application/pdf":
            {
                using var stream = file.OpenReadStream(maxFileSize);
                using var memoryStream = new MemoryStream();
                await stream.CopyToAsync(memoryStream);
                var buffer = memoryStream.ToArray();
                
                return new SupportfileFileUploadDbModel(entryDbModel.Id, file.Name, file.ContentType, buffer);
            }
            default:
                return null;
        }
    }

    private async Task DeleteFile(SupportfileFileUploadDbModel file)
    {
        if (_fileUploadPreview is null) return;
        await _fileUploadPreview.DeleteFile(file);
    }
    
    private async Task DownloadFile(SupportfileFileUploadDbModel file)
    {
        if (_fileUploadPreview is null) return;
        await _fileUploadPreview.DownloadFile(file);
    }

    private async Task RenameFile(SupportfileFileUploadDbModel file)
    {
        if (_fileUploadPreview is null) return;
        await _fileUploadPreview.RenameFile(file);
    }

    private void PreviewFile(SupportfileFileUploadDbModel file)
    {
        _fileUploadPreview?.OpenFile(file, false);
    }
    
    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        _isAuthorized = UserAccessService.HasRight(PageRightRegistry.GetNeededRankForPage(Url));
        _shouldRedirect = !_isAuthorized;
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;

        if (_shouldRedirect)
        {
            Navigation.NavigateToNotAuthorized();
            return;
        }
            
        await StartHubConnection();
        
        await FetchSupportfileById();
    }

    private async Task FetchSupportfileById()
    {
        _loading = true;
        StateHasChanged();
        
        await LoadModel();
        
        _loading = false;
        StateHasChanged();
    }

    private async Task LoadModel()
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        
        if (!Ulid.TryParse(Id, out var fileId))
        {
            Snackbar.Add("Parsing failed", Severity.Error);
            _loading = false;
            return;
        }
        
        var model = await SupportfileProxy.GetAsync(fileId);
        if (model is null)
        {
            Snackbar.Add("Ein Fehler beim Laden ist aufgetreten.", Severity.Error);
            _loading = false;
            return;
        }

        if (access.Rank < model.MinRank)
        {
            Navigation.NavigateToNotAuthorized();
            return;
        }

        _hasNeededRank = true;

        _model = model;
        _checkModel = _model.CreateShallowCopy();

        _allAccessModels = await AccessProxy.GetAllAsync();
        
        await LoadEntrys();
        StateHasChanged();
    }
    
    private async Task LoadEntrys()
    {
        if (_model is null) return;
        
        @if (UserAccessService.HasRight(RightEnum.ViewSupportfileEntrys))
        {
            var entrys = await SupportfileEntryProxy.GetAllEntrysForSupportfileIdAsync(_model.Id);
            _entrys = _showDeletedEntrys ? entrys : entrys.Where(x => !x.Deleted).ToList();
        }
        
        @if (UserAccessService.HasRight(RightEnum.SupportfileViewLogs))
        {
            _logs = await SupportfileLogsProxy.GetAllLogsForSupportfileIdAsync(_model.Id);
        }
        
        StateHasChanged();
    }

    private async Task OnClickCreate()
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        if (_model is null) return;
        if (!UserAccessService.HasRight(RightEnum.SupportfileCreateEntrys)) return;
        
        const string title = "Eintrag hinzufügen";
        const string description = "Welche Information möchtest du hinzufügen?";
        const string submitButtonText = "Eintrag hinzufügen";

        const string messageLabel = "Nachricht/Information";

        var inputs = new List<InputModel>
        {
            new(
                InputTypes.Text,
                messageLabel,
                string.Empty,
                "Am... Mit... Beschlossen...",
                _entryLines
            ),
        };

        var parameter = new DialogParameters<SimpleMudDialog>
        {
            { x => x.Description, description },
            { x => x.Inputs, inputs },
            { x => x.SubmitButtonText, submitButtonText },
        };

        var dialog = await DialogService.ShowAsync<SimpleMudDialog>(title, parameter, new DialogOptions { FullWidth = true });
        var dialogResult = await dialog.Result;

        if (dialogResult != null && dialogResult.Canceled) return;

        var data = (List<InputModel>)dialogResult.Data!;
        var message = data.First(x => x.Label == messageLabel).Value;

        if (string.IsNullOrEmpty(message))
        {
            Snackbar.Add("Es wurde keine Nachricht eingetragen!", Severity.Error);
            return;
        }

        var response = await SupportfileEntryProxy.AddEntryAsync(new SupportfileEntryDbModel(_model.Id, message, access.Id));
        if (response is null)
        {
            Snackbar.Add("Nachricht konnte nicht hinzugefügt werden!", Severity.Error);
            return;
        }

        await SendUpdateEntryToHub();
        await LoadEntrys();
    }

    private async Task StartHubConnection()
    {
        _hubConnection = HubHelper.GetHubConnection(Navigation, SupportfileHub.HubPattern);
        
        _hubConnection.On<Ulid>(SupportfileHubMethodEnum.UpdateFile.ToString(), async (id) =>
        {
            if (_model is null) return;
            if (id != _model.Id) return;
            
            await InvokeAsync(LoadModel);
            StateHasChanged();
        });
        
        _hubConnection.On<Ulid>(SupportfileHubMethodEnum.UpdateEntrys.ToString(), async (id) =>
        {
            if (_model is null) return;
            if (id != _model.Id) return;
            
            await InvokeAsync(LoadEntrys);
            StateHasChanged();
        });
        
        _hubConnection.On<Ulid>(SupportfileHubMethodEnum.ToggleFileDeleted.ToString(), (id) =>
        {
            if (_model is null) return;
            if (id != _model.Id) return;
            
            Navigation.NavigateTo(SupportfileOverview.GetRedirectUrl());
        });

        await _hubConnection.StartAsync();
    }
    
    private async Task SendUpdateEntryToHub()
    {
        if (_model is null) return;
        if (_hubConnection is null) return;
        
        await _hubConnection.SendAsync(SupportfileHubMethodEnum.UpdateEntrys.ToString(), _model.Id);
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is null) return;
        
        await _hubConnection.DisposeAsync();
    }

    private async Task EditEntry(SupportfileEntryDbModel entry)
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        if (_model is null) return;
        if (!UserAccessService.HasRight(RightEnum.SupportfileEditEntrys)) return;
        
        const string title = "Eintrag bearbeiten";
        var description = "Wie möchtest du den Eintrag bearbeiten?";
        const string submitButtonText = "Eintrag bearbeitet";

        const string messageLabel = "Nachricht/Information";

        var inputs = new List<InputModel>
        {
            new(
                InputTypes.Text,
                messageLabel,
                entry.Content,
                "Am... Mit... Beschlossen...",
                _entryLines
            ),
        };

        var parameter = new DialogParameters<SimpleMudDialog>
        {
            { x => x.Description, description },
            { x => x.Inputs, inputs },
            { x => x.SubmitButtonText, submitButtonText },
        };

        var dialog = await DialogService.ShowAsync<SimpleMudDialog>(title, parameter, new DialogOptions { FullWidth = true });
        var dialogResult = await dialog.Result;

        if (dialogResult != null && dialogResult.Canceled) return;

        var data = (List<InputModel>)dialogResult.Data!;
        var message = data.First(x => x.Label == messageLabel).Value;

        if (string.IsNullOrEmpty(message))
        {
            Snackbar.Add("Es wurde keine Nachricht eingetragen!", Severity.Error);
            return;
        }

        var response = await SupportfileEntryProxy.UpdateEntryContentAsync(entry.Id, message, access.Id);
        if (!response)
        {
            Snackbar.Add("Nachricht konnte nicht bearbeitet werden!", Severity.Error);
            return;
        }

        await SendUpdateEntryToHub();
    }

    private async Task RemoveEntry(SupportfileEntryDbModel entry)
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        if (_model is null) return;
        if (!UserAccessService.HasRight(RightEnum.SupportfileDeleteEntrys)) return;
        
        var result = await DialogService.ShowMessageBox(
            "Eintrag löschen", 
            "Bist du dir sicher diesen Eintrag zu löschen? Dies kann nicht mehr rückgängig gemacht werden!", 
            yesText:"Löschen!", cancelText:"Abbrechen"
        );

        if (result is null or false) return;

        var response = await SupportfileEntryProxy.RemoveEntryAsync(entry.Id, access.Id);
        if (!response)
        {
            Snackbar.Add("Dieser Eintrag konnte nicht gelöscht werden!");
            return;
        }
        
        await SendUpdateEntryToHub();
    }

    private async Task RestoreEntry(SupportfileEntryDbModel entry)
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        if (_model is null) return;
        if (!UserAccessService.HasRight(RightEnum.SupportfileDeleteEntrys)) return;
        
        var result = await DialogService.ShowMessageBox(
            "Eintrag wiederherstellen", 
            "Bist du dir sicher diesen Eintrag zu wiederherzustellen?", 
            yesText:"Wiederherstellen!", cancelText:"Abbrechen"
        );

        if (result is null or false) return;

        var response = await SupportfileEntryProxy.RestoreEntryAsync(entry.Id, access.Id);
        if (!response)
        {
            Snackbar.Add("Dieser Eintrag konnte nicht gelöscht werden!");
            return;
        }
        
        await SendUpdateEntryToHub();
    }


    private string GetSublineText(SupportfileEntryDbModel entry)
    {
        return $"{entry.Id}" + (entry.CreatedAtLocal != entry.ModifiedAtLocal ? $" - geändert {entry.ModifiedAtLocal}" : string.Empty);
    }
    
    private Func<SupportfileLogsDbModel, bool> QuickFilter => x =>
    {
        if (_logSearchString == null) return true;
        
        var lowerSearchString = _logSearchString.ToLower();
        
        if (string.IsNullOrWhiteSpace(lowerSearchString))
            return true;

        if (x.Content.ToLower().Contains(lowerSearchString, StringComparison.OrdinalIgnoreCase))
            return true;

        if (x.Type.ToString().ToLower().Contains(lowerSearchString, StringComparison.OrdinalIgnoreCase))
            return true;
        
        if (x.CreatedAtLocal().ToString(CultureInfo.InvariantCulture).ToLower().Contains(lowerSearchString, StringComparison.OrdinalIgnoreCase))
            return true;
        
        if ($"{x.Id}".ToLower().Contains(lowerSearchString))
            return true;

        return false;
    };

    private async Task ToggleFileDeleted()
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        if (_model is null) return;
        if (_hubConnection is null) return;

        if (_model.Deleted && !UserAccessService.HasRight(RightEnum.SupportfileRestore)) return;
        if (!_model.Deleted && !UserAccessService.HasRight(RightEnum.SupportfileDelete)) return;

        var title = _model.Deleted ? "Supportakte wiederherstellen" : "Supportakte löschen";
        var message = _model.Deleted ? 
            "Bist du dir sicher diese Supportakte wiederherzustellen?" : 
            "Bist du dir sicher diese Supportakte zu löschen? Dies kann nicht mehr rückgängig gemacht werden!";
        var yesText = _model.Deleted ? "Wiederherstellen" : "Löschen";
        
        var result = await DialogService.ShowMessageBox(
            title, 
            message, 
            yesText:yesText, cancelText:"Abbrechen"
        );

        if (result is null or false) return;

        var response = await SupportfileProxy.ToggleDeletedAsync(_model.Id, access.Id);
        if (!response)
        {
            Snackbar.Add("Dieser Eintrag konnte nicht gelöscht/wiederhergestellt werden!");
            return;
        }
        
        await _hubConnection.SendAsync(SupportfileHubMethodEnum.ToggleFileDeleted.ToString(), _model.Id);
    }

    private async Task SaveChanges()
    {
        var access = await UserAccessService.GetUserAccess();
        if (access is null) return;
        if (_hubConnection is null) return; 
        
        if (_model is null || _checkModel is null || access is null)
        {
            Snackbar.Add("Mögliche Änderungen konnte nicht aktualisiert werden.", Severity.Error);
            return;
        }

        var shouldReload = false;
        
        if (_checkModel.Title != _model.Title && UserAccessService.HasRight(RightEnum.SupportfileEditTitle))
        {
            var updateResponse = await SupportfileProxy.UpdateTitleAsync(_model.Id, _model.Title, access.Id);
            if (!updateResponse)
            {
                Snackbar.Add("Title konnte nicht aktualisiert werden.", Severity.Error);
            }
            else
            {
                Snackbar.Add("Title wurde aktualisiert.", Severity.Success);
                shouldReload = true;
            }
        }
        
        if (_checkModel.Description != _model.Description && UserAccessService.HasRight(RightEnum.SupportfileEditDescription))
        {
            var updateResponse = await SupportfileProxy.UpdateDescriptionAsync(_model.Id, _model.Description, access.Id);
            if (!updateResponse)
            {
                Snackbar.Add("Description konnte nicht aktualisiert werden.", Severity.Error);
            }
            else
            {
                Snackbar.Add("Description wurde aktualisiert.", Severity.Success);
                shouldReload = true;
            }
        }
        
        if (_checkModel.Status != _model.Status && UserAccessService.HasRight(RightEnum.SupportfileEditStatus))
        {
            var updateResponse = await SupportfileProxy.UpdateStatusAsync(_model.Id, _model.Status, access.Id);
            if (!updateResponse)
            {
                Snackbar.Add("Status konnte nicht aktualisiert werden.", Severity.Error);
            }
            else
            {
                Snackbar.Add("Status wurde aktualisiert.", Severity.Success);
                shouldReload = true;
            }
        }
        
        if (_checkModel.MinRank != _model.MinRank && UserAccessService.HasRight(RightEnum.SupportfileEditMinRank))
        {
            var updateResponse = await SupportfileProxy.UpdateMinRankAsync(_model.Id, _model.MinRank, access.Id);
            if (!updateResponse)
            {
                Snackbar.Add("MinRank konnte nicht aktualisiert werden.", Severity.Error);
            }
            else
            {
                Snackbar.Add("MinRank wurde aktualisiert.", Severity.Success);
                shouldReload = true;
            }
        }

        if (!shouldReload) return;
        
        await _hubConnection.SendAsync(SupportfileHubMethodEnum.UpdateFile.ToString(), _model.Id);
    }

    private async Task ToggleShowDeletedEntrys()
    {
        _showDeletedEntrys = !_showDeletedEntrys;

        await LoadEntrys();
    }
}